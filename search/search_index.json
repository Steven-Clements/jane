{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Meet Jane","text":"<p>Less boilerplate. More workflow.</p> <p>Zero\u2011side\u2011effect helpers for predictable data sanity.</p> <p>Jane is a small, clarity\u2011first helper library for normalizing, validating, and safely parsing unknown input in JavaScript and TypeScript.</p> <p>It\u2019s built for developers who want predictable behavior, composable pipelines, and zero surprises \u2014 without schema systems, decorators, or framework lock\u2011in.</p> <ul> <li>Jane is not a schema builder.</li> <li>Jane is not a type generator.</li> <li>Jane is not a runtime type system.</li> </ul> <p>Jane is intentionally small. Intentionally explicit. Intentionally boring in all the right ways.</p>"},{"location":"#why-jane","title":"Why Jane?","text":"<p>Most validation libraries try to be everything: schema builders, type generators, transformers, parsers, refiners, and runtime type systems.</p> <p>Jane takes the opposite approach.</p> <p>Jane is:</p> <ul> <li>Pure: No side effects, no hidden mutations.</li> <li>Deterministic: Same input, same output, every time.</li> <li>Composable: Build pipelines with <code>pipe()</code>.</li> <li>Zero\u2011dependency: No runtime weight.</li> <li>Framework\u2011agnostic: Works in Node, serverless, workers, Express, Fastify, Bun, Deno.</li> <li>Focused: Normalization \u2192 validation \u2192 result.</li> </ul> <p>If you want a dependable \"standard library\" for data sanity, Jane is your girl.</p>"},{"location":"#who-is-jane-for","title":"Who is Jane for?","text":"<p>Jane is designed for developers who:</p> <ul> <li>Prefer explicit, predictable behavior over magic.</li> <li>Want pure functions instead of schema DSLs.</li> <li>Need safe parsing for config, requests, queries, and internal boundaries.</li> <li>Value clarity and maintainability in long\u2011lived codebases.</li> <li>Dislike validators that throw.</li> <li>Want small, composable building blocks instead of monolithic schemas.</li> </ul> <p>If you\u2019ve ever written your own tiny normalizers and validators because existing libraries felt too heavy \u2014 Jane was built for you.</p>"},{"location":"#a-tiny-example","title":"A tiny example","text":"<pre><code>import {\n    normalizeString,\n    validateNumber,\n    pipe\n} from \"@steven-clements/jane\";\n\nconst parsePort = pipe(\n  normalizeString,\n  validateNumber,\n);\n\nparsePort(\"3000\"); // { ok: true, value: 3000 }\nparsePort(\"abc\");  // { ok: false, error: ... }\n</code></pre> <p>Jane stays out of your way. No schemas. No decorators. No magic.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>npm install @steven-clements/jane\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Explore our comprehensive documentation:</p> <ul> <li>Reference</li> <li>Contributing</li> </ul>"},{"location":"#license","title":"License","text":"<p>Jane is licensed under the Apache License, Version 2.0.</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Designed for clarity, composability, and long\u2011term maintainability.</p>"},{"location":"contributing/development-workflow/","title":"Follow the development workflow","text":"<p>Jane follows a clarity\u2011first, contract\u2011driven workflow. Every change begins with an explicit description of the intended behavior before any implementation work is done. This prevents ambiguity, reduces regressions, and keeps the codebase predictable.</p> <p>The workflow is:</p> <ol> <li> <p>Write a reference topic</p> <p>Describe the module\u2019s purpose, inputs, outputs, constraints, and edge cases in <code>docs/reference/</code>.</p> <p>The reference topic is the human\u2011readable source of truth. It defines the contract that all tests and implementations must follow.</p> </li> <li> <p>Write the tests</p> <p>Translate the reference topic into executable expectations using Vitest.</p> <p>Tests should cover:</p> <ul> <li>Expected behavior  </li> <li>Invalid inputs  </li> <li>Edge cases  </li> <li>Type\u2011level expectations (if applicable)  </li> <li>No coercion or magic behavior  </li> </ul> <p>Tests are the executable contract. They must reflect the spec \u2014 no more, no less.</p> </li> <li> <p>Write the implementation</p> <p>Implement the module so that it satisfies the spec and passes all tests.</p> <p>Keep modules small, explicit, and free of side effects. Avoid cleverness; prefer clarity and predictability.</p> </li> <li> <p>Update documentation</p> <p>If the change affects public behavior, update the relevant docs in <code>docs/</code>.</p> <p>Documentation must always match actual behavior. No drift, no ambiguity.</p> </li> <li> <p>Commit using semantic messages</p> <p>Use Conventional Commits to ensure automated releases and changelog updates:</p> <ul> <li><code>feat:</code> for new features  </li> <li><code>fix:</code> for bug fixes  </li> <li><code>docs:</code> for documentation changes  </li> <li><code>refactor:</code> for internal changes  </li> <li><code>test:</code> for test\u2011only changes  </li> <li><code>chore:</code> for non\u2011code tasks  </li> </ul> </li> </ol> <p>This workflow ensures that behavior is defined before it is implemented, tests reflect the intended contract, and the codebase remains explicit, predictable, and maintainable \u2014 the core of Jane\u2019s philosophy.</p>"},{"location":"contributing/development-workflow/#next-up","title":"Next up","text":"<p>Restricted repo files</p>"},{"location":"contributing/overview/","title":"Contributing","text":"<p>This section documents how to contribute to Jane in a clear, predictable, and maintainable way. It covers the development workflow and the rules that keep the repository stable.</p> <ul> <li>Development workflow</li> <li>Restricted files and directories</li> </ul>"},{"location":"contributing/restricted-repo-files/","title":"Restricted repo files","text":"<p>This project uses automated tooling for releases, formatting, documentation, and configuration.</p> <p>To keep the repository stable and predictable, certain files must not be edited in pull requests unless explicitly requested by a maintainer.</p>"},{"location":"contributing/restricted-repo-files/#do-not-modify-these-files","title":"Do not modify these files","text":"<ul> <li>CHANGELOG.md \u2014 Automatically generated by the release pipeline. Any manual edits will be overwritten.</li> <li>CODEOWNERS \u2014 Defines review and approval rules. Changes require maintainer approval and are not accepted through general PRs.</li> <li>LICENSE \u2014 Legal document. Only maintainers may update it.</li> </ul>"},{"location":"contributing/restricted-repo-files/#release-and-automation-configs","title":"Release and automation configs","text":"<p>These files are part of the automated release and CI/CD pipeline and must remain stable:</p> <ul> <li><code>.releaserc</code> or <code>release.config.*</code></li> <li><code>.github/workflows/*</code></li> <li><code>package.json</code> (release\u2011related fields)</li> <li><code>semantic-release</code> configuration</li> </ul>"},{"location":"contributing/restricted-repo-files/#formatting-and-linting-configs","title":"Formatting and linting configs","text":"<p>These define the project\u2019s formatting and linting rules:</p> <ul> <li><code>prettier.config.*</code></li> <li><code>eslint.config.*</code></li> <li><code>.editorconfig</code></li> <li><code>tsconfig.json</code></li> <li><code>vitest.config.*</code></li> </ul>"},{"location":"contributing/restricted-repo-files/#rootlevel-configuration-files","title":"Root\u2011level configuration files","text":"<p>Unless a maintainer requests a change, do not modify files at the repository root (except <code>README.md</code> and <code>mkdocs.yml</code>).</p>"},{"location":"contributing/restricted-repo-files/#allowed-areas-for-contributions","title":"Allowed areas for contributions","text":"<p>Most contributions should be limited to:</p> <ul> <li><code>mkdocs.yml</code> \u2014 Documentation site navigation.</li> <li><code>README.md</code> \u2014 General project information (raise the bar!).</li> <li><code>src/</code> \u2014 Implementation.</li> <li><code>tests/</code> \u2014 Test suites.</li> <li><code>docs/</code> \u2014 Documentation.</li> <li><code>coverage/</code> \u2014 Generated coverage artifacts (rarely edited manually).</li> </ul>"},{"location":"contributing/restricted-repo-files/#exceptions","title":"Exceptions","text":"<p>If a change to a restricted file is required to fix a bug, improve documentation, or resolve a configuration issue, open an issue first.</p> <p>A maintainer will confirm whether the change is appropriate before a PR is opened.</p> <p>This policy ensures:</p> <ul> <li>Consistent automation.</li> <li>Predictable releases.</li> <li>Stable contributor experience.</li> <li>Clear separation between code and infrastructure.</li> </ul>"},{"location":"contributing/restricted-repo-files/#next-up","title":"Next up","text":"<p>This is the final reference topic. Our reference section is up next, containing detailed specifications for every module.</p> <p>Reference</p>"},{"location":"reference/overview/","title":"Reference","text":"<p>The Reference section documents every helper in Jane. Each page includes a clear description, the function signature, parameter tables, return shapes, examples, and notes. All helpers follow the same predictable structure so you can find what you need quickly.</p> <p>Use this section when you already understand the concepts and workflows and need precise, implementation\u2011level details about a specific helper.</p>"},{"location":"reference/overview/#whats-included","title":"What\u2019s included","text":"<p>Jane\u2019s helpers are organized into several categories. Each category has its own index page and detailed entries for every function.</p> <ul> <li>Type guards: Safe checks for types and shapes.</li> <li>Normalizers: Pure functions that convert unknown input into predictable forms.</li> <li>Validators: Boolean or result\u2011based checks for correctness.</li> <li>Pipelines \u2014 Tools like <code>pipe()</code> for composing helpers.</li> </ul> <p>Each category is intentionally small and focused.</p>"},{"location":"reference/overview/#type-guards","title":"Type guards","text":"<p>Helpers that check types and shapes without throwing.</p> <p>Use these when you need safe branching logic or want to narrow unknown input before normalization or validation.</p> <p>Learn more</p>"},{"location":"reference/overview/#how-to-read-this-section","title":"How to read this section","text":"<p>Every helper is documented with the same predictable structure:</p> <ul> <li>A short description.</li> <li>The function signature.</li> <li>A parameter table.</li> <li>The return shape.</li> <li>Examples.</li> <li>Notes and edge cases.</li> </ul> <p>All entries are self\u2011contained, deterministic, and free of side effects.</p> <p>You can read them in any order.</p>"},{"location":"reference/normalizers/","title":"Normalizers","text":"<p>Normalizers take unknown, messy, or inconsistent input and convert it into predictable, well\u2011formed values. They never throw exceptions, never mutate input, and never perform hidden coercion. A normalizer either returns a clean value or null when normalization is not possible.</p> <p>Normalizers in Jane are pure, explicit, and side\u2011effect\u2011free. They make downstream validation and parsing safer, clearer, and easier to reason about.</p>"},{"location":"reference/normalizers/#available-normalizers","title":"Available normalizers","text":"<p>Normalizers are grouped by category for clarity and discoverability:</p> <ul> <li>Primitives: Trim, canonicalize, or safely interpret primitive values.</li> </ul> <p>Each normalizer is small, focused, and designed to be composed with others.</p>"},{"location":"reference/normalizers/#when-to-use-normalizers","title":"When to use normalizers","text":"<p>Use normalizers when:</p> <ul> <li>You want predictable input before validation or parsing.</li> <li>You need to clean or standardize user\u2011provided values.</li> <li>You want to avoid ad\u2011hoc trimming, coercion, or defensive checks.</li> <li>You want to collapse messy input into a consistent shape.</li> <li>You want to separate \u201ccleaning\u201d from \u201cvalidating\u201d for clarity.</li> </ul> <p>Normalizers help you build pipelines that are explicit, readable, and safe. They ensure that every value entering a validator or parser is already well\u2011formed, reducing complexity and eliminating entire classes of bugs.</p>"},{"location":"reference/normalizers/#why-normalizers-matter","title":"Why normalizers matter","text":"<p>Normalizers form the second layer of Jane\u2019s runtime model:</p> <p><code>type guards \u2192 normalizers \u2192 validators \u2192 parsers</code></p> <ul> <li>Type guards tell you what a value is.</li> <li>Normalizers tell you what shape it should be.</li> <li>Validators tell you whether it\u2019s acceptable.</li> <li>Parsers combine all three into a typed result.</li> </ul> <p>Normalizers keep your workflows clean and intentional. They remove ambiguity, reduce branching, and ensure that every step of your pipeline receives predictable input.</p>"},{"location":"reference/normalizers/primitives/","title":"Overview","text":"<p>Primitive normalizers convert unknown or inconsistent input into predictable primitive values. They never throw exceptions, never mutate input, and never perform hidden coercion. Each helper returns either a clean, well\u2011formed value or null when normalization is not possible.</p> <p>Primitive normalizers are the simplest and most frequently used normalization tools in Jane. They help you prepare raw input for validation or parsing by ensuring that values are trimmed, canonicalized, or safely interpreted.</p> <ul> <li>normalizeBoolean: Interprets native booleans and <code>\"true\"</code> or <code>\"false\"</code> strings.</li> <li>normalizeFiniteNumber:</li> <li>normalizeInteger: Converts native integers and integer strings into finite integers.</li> <li>normalizeNonEmptyString: Trims native strings and returns a non\u2011empty result or <code>null</code>.</li> <li>normalizeNonNegativeNumber:</li> <li>normalizeNumber: Converts native numbers and numeric strings into finite numbers.</li> <li>normalizePositiveInteger:</li> <li>normalizeSafeInteger:</li> <li>normalizeString: Trims native strings and returns them unchanged.</li> </ul> <p>Each helper is pure, predictable, and designed to be composed with validators and parsers.</p>"},{"location":"reference/normalizers/primitives/#when-to-use-primitive-normalizers","title":"When to use primitive normalizers","text":"<p>Use primitive normalizers when:</p> <ul> <li>You want predictable values before validation.</li> <li>You need to clean or standardize user\u2011provided input.</li> <li>You want to avoid ad\u2011hoc trimming, coercion, or defensive checks.</li> <li>You want to separate \u201ccleaning\u201d from \u201cvalidating\u201d for clarity.</li> </ul> <p>Primitive normalizers form the foundation of safe, explicit data pipelines in Jane. They ensure that every downstream step receives well\u2011formed input, reducing complexity and eliminating ambiguity.</p>"},{"location":"reference/normalizers/primitives/normalize-boolean/","title":"normalizeBoolean","text":"<p>Normalizes a value into a boolean or returns <code>null</code>. This helper accepts native booleans and string representations of booleans (<code>\"true\"</code> and <code>\"false\"</code>).</p> <p>It never throws and never mutates input. Use it when you need a predictable boolean before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-boolean/#signature","title":"Signature","text":"<pre><code>function normalizeBoolean(value: unknown): boolean | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-boolean/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a boolean."},{"location":"reference/normalizers/primitives/normalize-boolean/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li><code>true</code> or <code>false</code>.</li> <li><code>null</code>: If the value cannot be interpreted as a boolean.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-boolean/#behavior","title":"Behavior","text":"<ul> <li>If the value is already a boolean, it is returned unchanged.</li> <li>If the value is a string, it is trimmed and lowercased.</li> <li><code>\"true\"</code> becomes <code>true</code>, <code>\"false\"</code> becomes <code>false</code>.</li> <li>All other values return <code>null</code>.</li> <li>No mutation, no exceptions, no hidden coercion.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-boolean/#examples","title":"Examples","text":"<pre><code>normalizeBoolean(true)            // true\nnormalizeBoolean(false)           // false\n\nnormalizeBoolean(\"true\")          // true\nnormalizeBoolean(\"  TRUE  \")      // true\nnormalizeBoolean(\"false\")         // false\nnormalizeBoolean(\" False \")       // false\n\nnormalizeBoolean(\"yes\")           // null\nnormalizeBoolean(1)               // null\nnormalizeBoolean(0)               // null\nnormalizeBoolean(null)            // null\nnormalizeBoolean(undefined)       // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-boolean/#notes","title":"Notes","text":"<ul> <li>Only the exact strings <code>\"true\"</code> and <code>\"false\"</code> (case\u2011insensitive, trimmed) are accepted.</li> <li>This helper does not coerce truthy/falsy values like <code>1</code>, <code>0</code>, <code>\"yes\"</code>, <code>\"no\"</code>, or empty strings.</li> <li>Use <code>validateBoolean</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-boolean/#next-up","title":"Next up","text":"<p>normalizeString</p>"},{"location":"reference/normalizers/primitives/normalize-finite-number/","title":"normalizeFiniteNumber","text":"<p>Normalizes a value into a finite JavaScript number or returns <code>null</code>.</p> <p>This helper accepts native numbers and string representations of finite numbers. It rejects non\u2011finite values, scientific notation, malformed decimals, and any form of coercion. It never throws and never mutates input. Use this when you need a guaranteed finite number before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-finite-number/#signature","title":"Signature","text":"<pre><code>function normalizeFiniteNumber(value: unknown): number | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-finite-number/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a finite number."},{"location":"reference/normalizers/primitives/normalize-finite-number/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A finite number.</li> <li><code>null</code>: If the value cannot be interpreted as a finite number.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-finite-number/#behavior","title":"Behavior","text":"<ul> <li>Accepts finite numbers.</li> <li>Accepts digit\u2011only or decimal strings with an optional leading hyphen (<code>-</code>).</li> <li>Trims string input before evaluation.</li> <li>Rejects:</li> <li><code>Infinity</code>, <code>-Infinity</code>, <code>NaN</code></li> <li>Scientific notation (\"1e3\")</li> <li>Signed strings with plus signs (\"+\")</li> <li>Malformed decimals (\"3.14.15\")</li> <li>Any non\u2011string, non\u2011number values</li> <li>No coercion is performed.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-finite-number/#examples","title":"Examples","text":"<pre><code>normalizeFiniteNumber(3.14)         // 3.14\nnormalizeFiniteNumber(\"42\")         // 42\nnormalizeFiniteNumber(\"0007\")       // 7\nnormalizeFiniteNumber(\" -12.5 \")    // -12.5\n\nnormalizeFiniteNumber(Infinity)     // null\nnormalizeFiniteNumber(\"1e3\")        // null\nnormalizeFiniteNumber(\"+5\")         // null\nnormalizeFiniteNumber(\"abc\")        // null\nnormalizeFiniteNumber(null)         // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-finite-number/#notes","title":"Notes","text":"<ul> <li>Only plain numeric strings (integer or decimal) are accepted.</li> <li>Scientific notation, signed values with (<code>+</code>), and malformed decimals are intentionally rejected.</li> <li>Use <code>validateFiniteNumber</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-integer/","title":"normalizeInteger","text":"<p>Normalizes a value into an integer or returns <code>null</code>. This helper accepts finite native integers and string representations of integers. It trims string input before parsing and rejects floats, <code>NaN</code>, <code>Infinity</code>, and malformed numeric values.</p> <p>It never throws and never mutates input. Use this when you need a predictable integer before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-integer/#signature","title":"Signature","text":"<pre><code>function normalizeInteger(value: unknown): number | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into an integer."},{"location":"reference/normalizers/primitives/normalize-integer/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A finite integer.</li> <li><code>null</code>: If the value cannot be interpreted as an integer.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-integer/#behavior","title":"Behavior","text":"<ul> <li>Accepts finite native integers.</li> <li>Scientific notation is allowed when it normalizes to an integer.</li> <li>Accepts integer strings (trimmed before parsing).</li> <li>Rejects:</li> <li>Floats.</li> <li><code>NaN</code>.</li> <li><code>Infinity</code> and <code>-Infinity</code>.</li> <li>Empty strings.</li> <li>Whitespace\u2011only strings.</li> <li>Malformed numeric strings.</li> <li>All non\u2011string, non\u2011number values.</li> <li>No mutation, no exceptions, no hidden coercion.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-integer/#examples","title":"Examples","text":"<pre><code>normalizeInteger(42)            // 42\nnormalizeInteger(\"42\")          // 42\nnormalizeInteger(\"  -10  \")     // -10\n\nnormalizeInteger(3.14)          // null\nnormalizeInteger(\"3.14\")        // null\nnormalizeInteger(\"\")            // null\nnormalizeInteger(\"abc\")         // null\nnormalizeInteger(Infinity)      // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-integer/#notes","title":"Notes","text":"<ul> <li>Use normalizeSafeInteger if you need to enforce the safe integer range.</li> <li>Use <code>validateInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-non-empty-string/","title":"normalizeNonEmptyString","text":"<p>Normalizes a value into a trimmed, non\u2011empty string or returns <code>null</code>.</p> <p>This helper accepts only native JavaScript strings. It trims leading and trailing whitespace and rejects empty results. It never throws and never mutates input. Use this when you need a guaranteed non\u2011empty string before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-non-empty-string/#signature","title":"Signature","text":"<pre><code>function normalizeNonEmptyString(value: unknown): string | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-non-empty-string/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize to a non-empty string."},{"location":"reference/normalizers/primitives/normalize-non-empty-string/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A trimmed, non\u2011empty string.</li> <li><code>null</code>: If the value is not a string or becomes empty after trimming.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-non-empty-string/#behavior","title":"Behavior","text":"<ul> <li>Only native strings are accepted.</li> <li>The returned string is trimmed.</li> <li>If the trimmed result is empty, <code>null</code> is returned.</li> <li>All non\u2011string values return <code>null</code>.</li> <li>No coercion (for example, converting numbers to strings) is performed.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-non-empty-string/#examples","title":"Examples","text":"<pre><code>normalizeNonEmptyString(\"hello\")        // \"hello\"\nnormalizeNonEmptyString(\"  hello  \")    // \"hello\"\n\nnormalizeNonEmptyString(\"\")             // null\nnormalizeNonEmptyString(\"   \")          // null\n\nnormalizeNonEmptyString(123)            // null\nnormalizeNonEmptyString(null)           // null\nnormalizeNonEmptyString(undefined)      // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-non-empty-string/#notes","title":"Notes","text":"<ul> <li>Use normalizeString if empty strings should be preserved.</li> <li>Use <code>validateNonEmptyString</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-non-negative-number/","title":"normalizeNonNegativeNumber","text":"<p>Normalizes a value into a non\u2011negative finite number (zero or greater) or returns <code>null</code>.</p> <p>This helper accepts native numbers and string representations of non\u2011negative numbers. It rejects negative values, non\u2011finite numbers, scientific notation, and any form of coercion. It never throws and never mutates input. Use this when you need a guaranteed non\u2011negative number before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-non-negative-number/#signature","title":"Signature","text":"<pre><code>function normalizeNonNegativeNumber(value: unknown): number | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-non-negative-number/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a non\u2011negative number."},{"location":"reference/normalizers/primitives/normalize-non-negative-number/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A non\u2011negative finite number.</li> <li><code>null</code>: If the value cannot be interpreted as a non\u2011negative number.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-non-negative-number/#behavior","title":"Behavior","text":"<ul> <li>Accepts finite numbers greater than or equal to zero.</li> <li>Accepts digit\u2011only or decimal strings (e.g., \"3\", \"3.14\", \"0007\").</li> <li>Trims string input before evaluation.</li> <li>Rejects:</li> <li>Negative numbers.</li> <li>Non\u2011finite numbers (Infinity, NaN).</li> <li>Signed strings (+5, -1).</li> <li>Scientific notation (\"1e3\").</li> <li>Malformed decimals (\"3.14.15\").</li> <li>Any non\u2011string, non\u2011number values.</li> <li>No coercion is performed.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-non-negative-number/#examples","title":"Examples","text":"<pre><code>normalizeNonNegativeNumber(0)          // 0\nnormalizeNonNegativeNumber(3.14)       // 3.14\nnormalizeNonNegativeNumber(\"42\")       // 42\nnormalizeNonNegativeNumber(\"0007\")     // 7\nnormalizeNonNegativeNumber(\" 12.5 \")   // 12.5\n\nnormalizeNonNegativeNumber(-1)         // null\nnormalizeNonNegativeNumber(\"1e3\")      // null\nnormalizeNonNegativeNumber(\"+5\")       // null\nnormalizeNonNegativeNumber(\"abc\")      // null\nnormalizeNonNegativeNumber(null)       // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-non-negative-number/#notes","title":"Notes","text":"<ul> <li>Only plain numeric strings (integer or decimal) are accepted.</li> <li>Scientific notation, signed values, and malformed decimals are intentionally rejected.</li> <li>Use <code>validateNonNegativeNumber</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-number/","title":"normalizeNumber","text":"<p>Normalizes a value into a finite number or returns <code>null</code>.</p> <p>This helper accepts native numbers and numeric strings. It trims string input before parsing and rejects <code>NaN</code>, <code>Infinity</code>, and malformed numeric values. It never throws and never mutates input.</p> <p>Use this when you need a predictable number before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-number/#signature","title":"Signature","text":"<pre><code>function normalizeNumber(value: unknown): number | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-number/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a finite number."},{"location":"reference/normalizers/primitives/normalize-number/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A finite number.</li> <li><code>null</code>: If the value cannot be interpreted as a finite number.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-number/#behavior","title":"Behavior","text":"<ul> <li>Accepts finite native numbers.</li> <li>Accepts numeric strings (trimmed before parsing).</li> <li>Rejects:</li> <li><code>NaN</code>.</li> <li><code>Infinity</code> and <code>-Infinity</code>.</li> <li>Empty strings.</li> <li>Whitespace\u2011only strings.</li> <li>Malformed numeric strings.</li> <li>All non\u2011string, non\u2011number values.</li> <li>No mutation, no exceptions, no hidden coercion.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-number/#examples","title":"Examples","text":"<pre><code>normalizeNumber(42)            // 42\nnormalizeNumber(\"42\")          // 42\nnormalizeNumber(\"  3.14  \")    // 3.14\nnormalizeNumber(\"-10\")         // -10\n\nnormalizeNumber(\"\")            // null\nnormalizeNumber(\"abc\")         // null\nnormalizeNumber(\"42px\")        // null\nnormalizeNumber(NaN)           // null\nnormalizeNumber(Infinity)      // null\nnormalizeNumber(null)          // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-number/#notes","title":"Notes","text":"<ul> <li>Supports scientific notation.</li> <li>Use normalizeInteger or <code>normalizeSafeInteger</code> for stricter numeric domains.</li> <li>Use <code>validateNumber</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-positive-integer/","title":"normalizePositiveInteger","text":"<p>Normalizes a value into a positive integer (one or greater) or returns <code>null</code>.</p> <p>This helper accepts native numbers and string representations of positive integers. It rejects floats, negative values, scientific notation, and any form of coercion. It never throws and never mutates input. Use this when you need a guaranteed positive integer before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-positive-integer/#signature","title":"Signature","text":"<pre><code>function normalizePositiveInteger(value: unknown): number | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-positive-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a positive integer."},{"location":"reference/normalizers/primitives/normalize-positive-integer/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A positive integer.</li> <li><code>null</code>: If the value cannot be interpreted as a positive integer.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-positive-integer/#behavior","title":"Behavior","text":"<ul> <li>Accepts finite, integer numbers greater or equal to one.</li> <li>Accepts digit\u2011only strings (leading zeros allowed).</li> <li>Trims string input before evaluation.</li> <li>Rejects:</li> <li>Empty or whitespace\u2011only strings.</li> <li>Negative numbers.</li> <li>Zero.</li> <li>floats.</li> <li>Scientific notation.</li> <li>Signed strings (+5, -1).</li> <li>Any non\u2011string, non\u2011number values.</li> <li>No coercion is performed.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-positive-integer/#examples","title":"Examples","text":"<pre><code>normalizePositiveInteger(5)          // 5\nnormalizePositiveInteger(\"42\")       // 42\nnormalizePositiveInteger(\"0007\")     // 7\nnormalizePositiveInteger(\" 12 \")     // 12\n\nnormalizePositiveInteger(0)          // null\nnormalizePositiveInteger(-1)         // null\nnormalizePositiveInteger(3.14)       // null\nnormalizePositiveInteger(\"3.14\")     // null\nnormalizePositiveInteger(\"1e3\")      // null\nnormalizePositiveInteger(\"+5\")       // null\nnormalizePositiveInteger(\"abc\")      // null\nnormalizePositiveInteger(null)       // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-positive-integer/#notes","title":"Notes","text":"<ul> <li>Only digit\u2011only strings are accepted.</li> <li>Scientific notation, decimals, and signed values are intentionally rejected to avoid coercion surprises.</li> <li>Use <code>validatePositiveInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-safe-integer/","title":"normalizeSafeInteger","text":"<p>Normalizes a value into a safe integer (within JavaScript\u2019s <code>Number.MIN_SAFE_INTEGER</code> to <code>Number.MAX_SAFE_INTEGER</code> range) or returns <code>null</code>.</p> <p>This helper accepts native numbers and string representations of integers. It rejects floats, unsafe integers, scientific notation, signed strings with a plus sign, and any form of coercion. It never throws and never mutates input. Use this when you need a guaranteed safe integer before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-safe-integer/#signature","title":"Signature","text":"<pre><code>function normalizeSafeInteger(value: unknown): number | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-safe-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a safe integer."},{"location":"reference/normalizers/primitives/normalize-safe-integer/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A safe integer.</li> <li><code>null</code>: If the value cannot be interpreted as a safe integer.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-safe-integer/#behavior","title":"Behavior","text":"<ul> <li>Accepts finite, safe integers.</li> <li>Accepts digit\u2011only strings with an optional leading hyphen (<code>-</code>).</li> <li>Trims string input before evaluation.</li> <li>Rejects:</li> <li>Unsafe integers.</li> <li>Floats.</li> <li>Non\u2011finite numbers (<code>Infinity</code>, <code>NaN</code>).</li> <li>Scientific notation (\"1e3\").</li> <li>Signed strings with a plus sign (<code>+</code>).</li> <li>Malformed integers (\"--1\", \"3.14\").</li> <li>Any non\u2011string, non\u2011number values.</li> <li>No coercion is performed.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-safe-integer/#examples","title":"Examples","text":"<pre><code>normalizeSafeInteger(0)               // 0\nnormalizeSafeInteger(42)              // 42\nnormalizeSafeInteger(-7)              // -7\nnormalizeSafeInteger(\"0007\")          // 7\nnormalizeSafeInteger(\" -12 \")         // -12\n\nnormalizeSafeInteger(3.14)            // null\nnormalizeSafeInteger(\"3.14\")          // null\nnormalizeSafeInteger(\"1e3\")           // null\nnormalizeSafeInteger(\"+5\")            // null\nnormalizeSafeInteger(Number.MAX_SAFE_INTEGER + 1) // null\nnormalizeSafeInteger(null)            // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-safe-integer/#notes","title":"Notes","text":"<ul> <li>Only plain integer strings (optionally negative) are accepted.</li> <li>Scientific notation, decimals, and signed values with a plus sign (<code>+</code>) are intentionally rejected.</li> <li>Use <code>validateSafeInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-string/","title":"normalizeString","text":"<p>Normalizes a value into a trimmed string or returns <code>null</code>.</p> <p>This helper accepts only native JavaScript strings. It trims leading and trailing whitespace but performs no other transformations. It never throws and never mutates input.</p> <p>Use this when you need a predictable string before validation or further processing.</p>"},{"location":"reference/normalizers/primitives/normalize-string/#signature","title":"Signature","text":"<pre><code>function normalizeString(value: unknown): string | null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-string/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a string."},{"location":"reference/normalizers/primitives/normalize-string/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A trimmed string.</li> <li><code>null</code>: if the value is not a native string.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-string/#behavior","title":"Behavior","text":"<ul> <li>Only native strings are accepted.</li> <li>The returned string is trimmed.</li> <li>Empty strings remain empty after trimming.</li> <li>All non-string values return <code>null</code>.</li> <li>No coercion (for example, converting numbers to strings) is performed.</li> <li>No Unicode normalization or case folding is applied.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-string/#examples","title":"Examples","text":"<pre><code>normalizeString(\"hello\")          // \"hello\"\nnormalizeString(\"  hello  \")      // \"hello\"\nnormalizeString(\"\\nhello\\t\")      // \"hello\"\n\nnormalizeString(\"\")               // \"\"\nnormalizeString(\"   \")            // \"\"\n\nnormalizeString(123)              // null\nnormalizeString(true)             // null\nnormalizeString(null)             // null\nnormalizeString(undefined)        // null\nnormalizeString({})               // null\n</code></pre>"},{"location":"reference/normalizers/primitives/normalize-string/#notes","title":"Notes","text":"<ul> <li>Empty strings are valid normalized values and are never converted to <code>null</code>.</li> <li>This intentional behavior distinguishes <code>normalizeString</code> from <code>normalizeNonEmptyString</code>.</li> <li>Use normalizeNonEmptyString if you need to reject empty results.</li> <li>This helper is ideal for optional or flexible string fields.</li> <li>Use <code>validateString</code> if you need a <code>Result&lt;T&gt;</code> instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/primitives/normalize-string/#next-up","title":"Next up","text":"<p>normalizeNonEmptyString</p>"},{"location":"reference/normalizers/protocols/","title":"Overview","text":"<p>Protocol normalizers convert unknown input into predictable protocol\u2011level values such as iterables, async iterables, and promises. These helpers never throw exceptions, never mutate input, and never perform hidden coercion. Each normalizer returns either a clean, well\u2011formed protocol object or null when normalization is not possible.</p> <p>Protocol normalizers sit alongside primitive and structural normalizers, but focus specifically on JavaScript\u2019s iteration and asynchronous protocols. They ensure that values conform to the expected runtime interfaces before they are consumed by higher\u2011level utilities, pipelines, or parsers.</p> <ul> <li>normalizeAsyncIterable: Accepts any value implementing the asynchronous iteration protocol.</li> <li>normalizeIterable: Accepts any value implementing the synchronous iteration protocol.</li> <li>normalizePromise Accepts native promises and promise\u2011like objects.</li> </ul> <p>Each helper is pure, predictable, and designed to compose cleanly with structural and primitive normalizers.</p>"},{"location":"reference/normalizers/protocols/#when-to-use-protocol-normalizers","title":"When to use protocol normalizers","text":"<p>Use protocol normalizers when:</p> <ul> <li>You need to ensure a value implements a specific JavaScript protocol before consuming it.</li> <li>You want to reject \u201chostile\u201d or broken protocol implementations that throw when accessed.</li> <li>You want to avoid ad\u2011hoc typeof checks or manual iterator inspection.</li> <li>You want to separate \u201cprotocol conformance\u201d from \u201cvalue validation\u201d for clarity.</li> <li>You are building higher\u2011level utilities that operate on streams, iterables, or asynchronous workflows.</li> </ul> <p>Protocol normalizers form the foundation of Jane\u2019s streaming and asynchronous data pipelines. They guarantee that downstream consumers receive safe, well\u2011formed protocol objects, eliminating ambiguity and preventing runtime surprises.</p>"},{"location":"reference/normalizers/protocols/normalize-async-iterable/","title":"normalizeAsyncIterable","text":"<p>Normalizes an async\u2011iterable\u2011like value into a real async iterable or returns <code>null</code>.</p> <p>This helper provides a predictable way to work with asynchronous iteration without coercing non\u2011iterables or triggering iterator errors.</p>"},{"location":"reference/normalizers/protocols/normalize-async-iterable/#signature","title":"Signature","text":"<pre><code>function normalizeAsyncIterable&lt;T&gt;(\n    value: unknown\n): AsyncIterable&lt;T&gt; | null\n</code></pre>"},{"location":"reference/normalizers/protocols/normalize-async-iterable/#behavior","title":"Behavior","text":"<ul> <li>Returns async iterable with values unchanged.</li> <li>Accepts async generators and custom async iterables.</li> <li>Rejects non\u2011async\u2011iterable values.</li> <li>Rejects objects whose async iterator throws when accessed or invoked.</li> <li>Never throws and never mutates input.</li> <li>Does not attempt to convert plain values into async iterables.</li> </ul> <pre><code>Examples\nasync function* gen() {\n    yield 1\n}\n\nnormalizeAsyncIterable(gen())\n// returns the async generator object\n\nnormalizeAsyncIterable({}) \n// returns null\n\nnormalizeAsyncIterable({\n    [Symbol.asyncIterator]() { throw new Error(\"nope\") }\n})\n// returns null\n</code></pre>"},{"location":"reference/normalizers/protocols/normalize-async-iterable/#notes","title":"Notes","text":"<ul> <li>This helper is ideal when you want to accept any async iterable value but reject everything else.</li> <li>It protects against hostile or broken async iterator implementations.</li> <li>Use <code>validateAsyncIterable</code> if you need a <code>Result&lt;T&gt;</code> wrapper instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/protocols/normalize-iterable/","title":"normalizeIterable","text":"<p>Normalizes an iterable\u2011like value into a real iterable or returns <code>null</code>.</p> <p>This helper provides a predictable way to work with iterable values without coercing non\u2011iterables or triggering iterator errors.</p> <pre><code>Signature\nfunction normalizeIterable&lt;T&gt;(\n    value: unknown\n): Iterable&lt;T&gt; | null\n</code></pre>"},{"location":"reference/normalizers/protocols/normalize-iterable/#behavior","title":"Behavior","text":"<ul> <li>Returns iterable values unchanged</li> <li>Accepts strings, arrays, sets, maps, typed arrays, generators, and custom iterables</li> <li>Functions are not considered iterable, even if they define a <code>Symbol.iterator</code>.</li> <li>Rejects non\u2011iterable values</li> <li>Rejects objects whose iterator throws when accessed or invoked</li> <li>Never throws and never mutates input</li> <li>Does not attempt to convert plain values into iterables</li> </ul> <pre><code>Examples\nnormalizeIterable([1, 2, 3])\n// returns the array\n\nnormalizeIterable(\"abc\")\n// returns the string\n\nnormalizeIterable(new Set([1, 2]))\n// returns the set\n\nnormalizeIterable({}) \n// returns null\n\nnormalizeIterable({ [Symbol.iterator]: () =&gt; { throw new Error(\"nope\") } })\n// returns null\n</code></pre>"},{"location":"reference/normalizers/protocols/normalize-iterable/#notes","title":"Notes","text":"<ul> <li>This helper does not accept async iterables. Use normalizeAsyncIterable for those.</li> <li>This helper is ideal when you want to accept any iterable value but reject everything else.</li> <li>It protects against hostile or broken iterator implementations.</li> <li>Use <code>validateIterable</code> if you need a <code>Result&lt;T&gt;</code> wrapper instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/protocols/normalize-promise/","title":"normalizePromise","text":"<p>Normalizes a promise\u2011like value into a real <code>Promise</code> or returns <code>null</code>.</p> <p>This helper provides a predictable way to work with asynchronous values without coercing unrelated types or triggering unhandled rejections.</p>"},{"location":"reference/normalizers/protocols/normalize-promise/#signature","title":"Signature","text":"<pre><code>function normalizePromise&lt;T&gt;(\n    value: unknown\n): Promise&lt;T&gt; | null\n</code></pre>"},{"location":"reference/normalizers/protocols/normalize-promise/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> A value that may represent a <code>Promise</code> or a thenable."},{"location":"reference/normalizers/protocols/normalize-promise/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A real <code>Promise</code>.</li> <li><code>null</code>: If the value cannot be interpreted as a <code>Promise</code> or a safe thenable.</li> </ul> <p>Behavior</p> <ul> <li>Returns a real Promise unchanged.</li> <li>Wraps thenable objects in a real <code>Promise</code>.</li> <li>Detects and rejects thenables that throw when invoked.</li> <li>Detects and rejects thenables that reject synchronously.</li> <li>Never throws and never mutates input.</li> <li>Never triggers unhandled rejections.</li> <li>Does not attempt to convert plain values into promises.</li> </ul>"},{"location":"reference/normalizers/protocols/normalize-promise/#examples","title":"Examples","text":"<pre><code>normalizePromise(Promise.resolve(5))\n// returns the same promise\n\nnormalizePromise({ then: r =&gt; r(10) })\n// returns a real promise that resolves to ten\n\nnormalizePromise({ then() { throw new Error(\"failure\") } })\n// returns null\n\nnormalizePromise(123)\n// returns null\n</code></pre>"},{"location":"reference/normalizers/protocols/normalize-promise/#notes","title":"Notes","text":"<ul> <li>This helper is intended for safe ingestion of asynchronous values.</li> <li>It distinguishes between real <code>Promises</code> and arbitrary objects with a then method.</li> <li>It rejects unsafe or hostile thenables to avoid unhandled rejections.</li> <li>Use <code>validatePromise</code> if you need a <code>Result&lt;T&gt;</code> wrapper instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/semantic/","title":"Overview","text":"<p>Semantic normalizers convert unknown input into values that carry meaning, not just type. These helpers interpret raw data as dates, errors, regular expressions, timestamps, ports, and other domain\u2011specific primitives. They never throw exceptions, never mutate input, and never perform hidden coercion. Each helper returns either a well\u2011formed semantic value or null when normalization is not possible.</p> <p>Semantic normalizers sit above primitive and structural normalizers. They ensure that values conform to meaningful real\u2011world concepts before they are used in business logic, configuration, or parsing pipelines.</p> <ul> <li>normalizeJSON: Parses JSON strings into structured values.</li> <li>normalizeTimestamp: Converts numeric or string timestamps into finite millisecond values.</li> <li>normalizePort: Interprets numeric or string port values within the valid TCP/UDP port range.</li> </ul> <p>Each helper is pure, predictable, and designed to compose cleanly with primitive and structural normalizers.</p>"},{"location":"reference/normalizers/semantic/#when-to-use-semantic-normalizers","title":"When to use semantic normalizers","text":"<p>Use semantic normalizers when:</p> <ul> <li>You need to interpret raw input as a meaningful domain value.</li> <li>You want to reject malformed or ambiguous representations (e.g., invalid timestamps, malformed JSON).</li> <li>You want to avoid ad\u2011hoc parsing logic scattered throughout your codebase.</li> <li>You want to separate \u201cinterpretation\u201d from \u201cvalidation\u201d for clarity.</li> <li>You want to ensure downstream logic receives values that already carry semantic guarantees.</li> </ul> <p>Semantic normalizers form the bridge between raw input and meaningful application\u2011level concepts. They eliminate ambiguity, reduce boilerplate, and make your data pipelines explicit, predictable, and safe.</p>"},{"location":"reference/normalizers/semantic/normalize-json/","title":"normalizeJSON","text":"<p>Normalizes a JSON\u2011like value into a parsed JavaScript value or returns <code>null</code>. Supports a <code>strict</code>\u2011mode toggle for predictable, specification\u2011aligned parsing.</p>"},{"location":"reference/normalizers/semantic/normalize-json/#signature","title":"Signature","text":"<pre><code>function normalizeJSON(\n    value: unknown,\n    options?: { strict?: boolean }\n): unknown | null\n</code></pre>"},{"location":"reference/normalizers/semantic/normalize-json/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> A value that may represent JSON. options <code>object</code> with <code>strict</code> Enables strict parsing rules."},{"location":"reference/normalizers/semantic/normalize-json/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A parsed JavaScript value.</li> <li><code>null</code>: If the value cannot be interpreted as valid JSON.</li> </ul>"},{"location":"reference/normalizers/semantic/normalize-json/#behavior","title":"Behavior","text":"<ul> <li>Common behavior:</li> <li>Never throws or mutates input.</li> <li>Returns <code>null</code> for unsupported or invalid values.</li> <li>Non\u2011strict mode (default):</li> <li>Accepts objects and arrays and returns them unchanged.</li> <li>Accepts strings that <code>JSON.parse</code> can interpret.</li> <li>Allows leading and trailing whitespace.</li> <li>Rejects empty or whitespace\u2011only strings.</li> <li>Rejects invalid JSON strings.</li> <li>Strict mode:</li> <li>Accepts only strings</li> <li>Rejects strings with leading or trailing whitespace</li> <li>Rejects any string that is not valid JSON</li> <li>Rejects all non\u2011string inputs</li> </ul> <p>This mode is intended for predictable, specification\u2011aligned parsing where only canonical JSON is allowed.</p>"},{"location":"reference/normalizers/semantic/normalize-json/#notes","title":"Notes","text":"<ul> <li>Strict mode is ideal for configuration files, environment variables, and API boundaries.</li> <li>Non\u2011strict mode is ideal for user input or ingestion pipelines.</li> <li>Use <code>validateJSON</code> if you need a <code>Result&lt;T&gt;</code> wrapper instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/semantic/normalize-port/","title":"normalizePort","text":"<p>Normalizes a port\u2011like value into a valid TCP port number or returns <code>null</code>. Supports a strict\u2011mode toggle for predictable, configuration\u2011safe parsing.</p>"},{"location":"reference/normalizers/semantic/normalize-port/#signature","title":"Signature","text":"<pre><code>function normalizePort(\n    value: unknown,\n    options?: { strict?: boolean }\n): number | null\n</code></pre>"},{"location":"reference/normalizers/semantic/normalize-port/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> A value that may represent a TCP port number options object with <code>strict</code> Enables strict parsing rules"},{"location":"reference/normalizers/semantic/normalize-port/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A number representing a valid TCP port.</li> <li>Null if the value cannot be interpreted as a valid port.</li> </ul>"},{"location":"reference/normalizers/semantic/normalize-port/#behavior","title":"Behavior","text":"<ul> <li>Common behavior:</li> <li>Accepts only integer values within the valid TCP port range.</li> <li>Accepts strings that represent integers.</li> <li>Rejects negative numbers, non\u2011finite numbers, and numbers above the valid range.</li> <li>Rejects strings that contain anything other than digits.</li> <li>Never throws and never mutates input.</li> <li>Non\u2011strict mode (default):</li> <li>Accepts integer ports from 0 through 65535.</li> <li>Accepts strings that represent those integers.</li> <li>Allows leading zeros and surrounding whitespace.</li> <li>Strict mode:</li> <li>Accepts integer ports from 1 through 65535.</li> <li>Rejects zero.</li> <li>Accepts only digit\u2011only strings with no whitespace and no leading zeros.</li> <li>Rejects any string that contains anything other than digits.</li> </ul>"},{"location":"reference/normalizers/semantic/normalize-port/#notes","title":"Notes","text":"<ul> <li>This helper intentionally does not accept named pipes or service names.</li> <li>Use <code>strict</code> mode for configuration files, environment variables, and any boundary where predictable formatting is required.</li> <li>Use <code>validatePort</code> if you need a <code>Result&lt;T&gt;</code> wrapper instead of <code>null</code>.</li> </ul>"},{"location":"reference/normalizers/semantic/normalize-timestamp/","title":"normalizeTimestamp","text":"<p>Normalizes timestamp\u2011like input into a millisecond epoch number or returns <code>null</code>. Supports a <code>strict</code>-mode toggle for predictable, ISO\u2011only parsing.</p>"},{"location":"reference/normalizers/semantic/normalize-timestamp/#signature","title":"Signature","text":"<pre><code>function normalizeTimestamp(\n    value: unknown,\n    options?: { strict?: boolean }\n): number | null\n</code></pre>"},{"location":"reference/normalizers/semantic/normalize-timestamp/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> A value that may represent a timestamp. { strict?: boolean } Enables strict ISO-8601 parsing. <p>Returns</p> <p>One of:</p> <ul> <li>A number representing milliseconds since Unix epoch.</li> <li><code>null</code> if the value cannot be interpreted as a valid timestamp.</li> </ul>"},{"location":"reference/normalizers/semantic/normalize-timestamp/#behavior","title":"Behavior","text":"<ul> <li>Common behavior:</li> <li>A valid Date instance returns its millisecond timestamp.</li> <li>An invalid Date instance returns null.</li> <li>A finite number returns unchanged.</li> <li>A non\u2011finite number returns null.</li> <li>An empty string or a string made only of whitespace returns null.</li> <li>The helper never throws and never mutates the input.</li> <li>Non\u2011strict mode (default):</li> <li>Strings are passed to <code>Date.parse</code>.</li> <li>Any format the JS engine accepts is allowed.</li> <li>Useful for flexible ingestion of user input.</li> <li>Strict mode (<code>{ strict: true }</code>)</li> <li>Only accepts ISO\u20118601 strings:<ul> <li><code>YYYY-MM-DD</code>.</li> <li><code>YYYY-MM-DDTHH:mm:ssZ</code>.</li> <li><code>YYYY-MM-DDTHH:mm:ss\u00b1HH:mm</code>.</li> </ul> </li> <li>Rejects all other string formats.</li> <li>Ensures predictable, cross\u2011engine behavior.</li> <li>Still accepts valid <code>Date</code> instances and finite numbers.</li> </ul>"},{"location":"reference/normalizers/semantic/normalize-timestamp/#examples","title":"Examples","text":"<pre><code>normalizeTimestamp(\"2020-01-01\");\n// \u2192 1577836800000\n\nnormalizeTimestamp(\"January 1, 2020\");\n// \u2192 1577836800000 (non-strict mode)\n\nnormalizeTimestamp(\"January 1, 2020\", { strict: true });\n// \u2192 null\n\nnormalizeTimestamp(\"2020-01-01T12:30:00Z\", { strict: true });\n// \u2192 1577881800000\n\nnormalizeTimestamp(new Date(\"2020-01-01T00:00:00Z\"));\n// \u2192 1577836800000\n\nnormalizeTimestamp(NaN);\n// \u2192 null\n</code></pre>"},{"location":"reference/normalizers/semantic/normalize-timestamp/#notes","title":"Notes","text":"<ul> <li>Strict mode is ideal for API boundaries, schema validation, and reproducible parsing.</li> <li>Non\u2011strict mode is ideal for user\u2011entered data or ingestion pipelines.</li> <li>This helper does not attempt to correct malformed dates.</li> <li>Use <code>validateTimestamp</code> if you need a <code>Result&lt;T&gt;</code> wrapper instead of null.</li> </ul>"},{"location":"reference/normalizers/structural/","title":"Overview","text":"<p>Structural normalizers convert unknown or loosely\u2011typed input into predictable structural shapes such as arrays, tuples, records, and plain objects. They never throw exceptions, never mutate input, and never perform hidden coercion. Each helper returns either a clean, well\u2011formed structure or null when normalization is not possible.</p> <p>Structural normalizers sit one level above primitive normalizers. They ensure that collections, containers, and object\u2011like values have the correct shape before deeper validation or parsing occurs. These helpers are essential when working with user\u2011provided data, configuration objects, or any input that must conform to a specific structural contract.</p> <ul> <li>normalizePlainObject: Accepts only objects with <code>Object.prototype</code> or <code>null</code> prototypes.</li> <li>normalizeRecord: Normalizes key/value dictionaries using a value normalizer.</li> </ul> <p>Each helper is pure, predictable, and designed to compose cleanly with primitive normalizers, validators, and schema\u2011level utilities.</p>"},{"location":"reference/normalizers/structural/#when-to-use-structural-normalizers","title":"When to use structural normalizers","text":"<p>Use structural normalizers when:</p> <ul> <li>You need to ensure that input has the correct container shape before validating its contents.</li> <li>You want to reject exotic or unsafe objects (e.g., class instances, Maps, Sets, Dates).</li> <li>You want to enforce predictable iteration or key/value semantics.</li> <li>You want to separate \u201cshape checking\u201d from \u201cvalue checking\u201d for clarity.</li> <li>You want to build higher\u2011level validators or schema definitions on top of safe, canonical structures.</li> </ul> <p>Structural normalizers form the backbone of Jane\u2019s data\u2011modeling layer. They guarantee that every downstream step receives well\u2011formed containers, eliminating ambiguity and making complex validation pipelines easier to reason about and maintain.</p>"},{"location":"reference/normalizers/structural/normalize-plain-object/","title":"normalizePlainObject","text":"<p>Normalizes a plain-object-like value into a real plain object or returns <code>null</code>.</p> <p>This helper accepts objects whose prototype is either <code>Object.prototype</code> or <code>null</code>. It rejects arrays, functions, class instances, and built-in exotic objects. It never throws and never mutates input.</p> <p>Use this when you need to ensure that a value is a safe, JSON-like object before further processing or validation.</p>"},{"location":"reference/normalizers/structural/normalize-plain-object/#signature","title":"Signature","text":"<pre><code>function normalizePlainObject(value: unknown): Record&lt;string, unknown&gt; | null\n</code></pre>"},{"location":"reference/normalizers/structural/normalize-plain-object/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to normalize into a plain object."},{"location":"reference/normalizers/structural/normalize-plain-object/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A plain object \u2014 if the input is object-like and its prototype is Object.prototype or null.</li> <li><code>null</code>: If the value cannot be interpreted as a plain object.</li> </ul>"},{"location":"reference/normalizers/structural/normalize-plain-object/#behavior","title":"Behavior","text":"<ul> <li>Accepts:</li> <li>Objects whose prototype is exactly <code>Object.prototype</code>.</li> <li>Objects created using <code>Object.create(null)</code> (<code>null-prototype</code> objects).</li> <li>Rejects:</li> <li>Arrays.</li> <li>Functions.</li> <li>Class instances.</li> <li>Built-in objects: Map, Set, Date, RegExp, Error, etc.</li> <li>Objects with custom prototypes.</li> <li>Objects whose prototype getter throws.</li> <li>All non-object values.</li> </ul> <p>Uses <code>Reflect.getPrototypeOf</code> safely (wrapped in try/catch).</p>"},{"location":"reference/normalizers/structural/normalize-plain-object/#examples","title":"Examples","text":"<pre><code>normalizePlainObject({ a: 1 })               \n// { a: 1 }\n\nconst obj = Object.create(null)\nobj.x = 1\nnormalizePlainObject(obj)                    \n// { x: 1 }\n\nnormalizePlainObject([])                     \n// null\n\nnormalizePlainObject(new Map())              \n// null\n\nnormalizePlainObject(new (class Foo {})())   \n// null\n\nnormalizePlainObject(123)                    \n// null\nnormalizePlainObject(\"abc\")                  \n// null\nnormalizePlainObject(null)                   \n// null\n</code></pre>"},{"location":"reference/normalizers/structural/normalize-plain-object/#notes","title":"Notes","text":"<ul> <li>Use normalizeRecord if you want to enforce that all keys are strings and all values are serializable.</li> <li>Use <code>validatePlainObject</code> if you need structured error information instead of returning <code>null</code>.</li> <li>Plain objects are useful for JSON-like data structures, but for deep validation consider chaining with <code>validateObjectShape</code>, schemas, or normalizers for nested values.</li> </ul>"},{"location":"reference/normalizers/structural/normalize-record/","title":"normalizeRecord","text":"<p>Normalizes a plain\u2011object record by applying a value normalizer to each property.</p> <p>If any value fails normalization, the entire record is rejected.</p>"},{"location":"reference/normalizers/structural/normalize-record/#signature","title":"Signature","text":"<pre><code>function normalizeRecord&lt;T&gt;(\n    value: unknown,\n    normalizeValue: (v: unknown) =&gt; T | null\n): Record&lt;string, T&gt; | null\n</code></pre>"},{"location":"reference/normalizers/structural/normalize-record/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> A value that may represent a plain object normalizeValue <code>(v: unknown) \u2192 T</code> | <code>null</code> A normalizer applied to each property value."},{"location":"reference/normalizers/structural/normalize-record/#returns","title":"Returns","text":"<p>One of:</p> <ul> <li>A new <code>Record&lt;string, T&gt;</code> containing normalized values.</li> <li><code>null</code>: If the input is not a plain object.</li> <li><code>null</code>: If any property fails normalization.</li> </ul>"},{"location":"reference/normalizers/structural/normalize-record/#behavior","title":"Behavior","text":"<ul> <li>Accepts only plain objects whose prototype is <code>Object.prototype</code> or <code>null</code>.</li> <li>Rejects arrays, functions, class instances, Maps, Sets, Dates, RegExps, and other exotic objects.</li> <li>Applies the provided normalizer to each property value.</li> <li>Rejects the entire record if any value normalizes to <code>null</code>.</li> <li>Returns a new object; never mutates the input.</li> <li>Never throws.</li> </ul>"},{"location":"reference/normalizers/structural/normalize-record/#examples","title":"Examples","text":"<pre><code>const normalizeNumber = (v: unknown) =&gt;\n    typeof v === \"number\" ? v : null\n\nnormalizeRecord({ a: 1, b: 2 }, normalizeNumber)\n// returns { a: 1, b: 2 }\n\nnormalizeRecord({ a: 1, b: \"x\" }, normalizeNumber)\n// returns null\n\nnormalizeRecord(123, normalizeNumber)\n// returns null\n\nnormalizeRecord(Object.create(null), normalizeNumber)\n// returns a new object with the same keys and normalized values\n</code></pre>"},{"location":"reference/normalizers/structural/normalize-record/#notes","title":"Notes","text":"<ul> <li>This helper is ideal for validating configuration objects and JSON\u2011like dictionaries.</li> <li>It composes naturally with other normalizers such as <code>normalizeString</code>, <code>normalizeBoolean</code>, and <code>normalizePlainObject</code>.</li> <li>Use <code>validateRecord</code> if you need a <code>Result&lt;T&gt;</code> wrapper instead of <code>null</code>.</li> </ul>"},{"location":"reference/type-guards/","title":"Type guards","text":"<p>Type guards help you safely branch logic and validate shapes without throwing exceptions. They return simple booleans, never mutate input, and never coerce values. Use them when you need to confirm a value\u2019s type before running a normalization or validation step.</p> <p>Type guards in Jane are pure, predictable, and consistent. They make your workflows easier to read and easier to reason about.</p>"},{"location":"reference/type-guards/#available-type-guards","title":"Available type guards","text":"<p>Type guards are grouped by category for clarity and searchability:</p> <ul> <li>Primitives</li> <li>Structural</li> <li>Collections</li> <li>Semantic</li> <li>Protocols</li> </ul> <p>Each category contains small, focused helpers with zero side effects.</p>"},{"location":"reference/type-guards/#when-to-use-type-guards","title":"When to use type guards","text":"<p>Use type guards when:</p> <ul> <li>You need to branch logic based on type.</li> <li>You want to avoid exceptions and implicit coercion.</li> <li>You want predictable behavior in pipelines.</li> <li>You need to confirm a value\u2019s shape before normalization.</li> <li>You want defensive code without clutter or magic.</li> </ul> <p>Type guards are the simplest building blocks in Jane. They narrow unknown input, keep your workflows explicit, and form the foundation for safe normalization and validation</p> <p>Type guards are the simplest building blocks in Jane. They help you write clear, explicit workflows.</p>"},{"location":"reference/type-guards/collections/","title":"Overview","text":"<p>Collection type guards help you confirm whether a value is an instance of a specific built\u2011in collection type. They return simple booleans, never throw, and never mutate input.</p> <ul> <li>isMap: Checks whether a value is a <code>Map</code> instance.</li> <li>isSet: Checks whether a value is a <code>Set</code> instance.</li> <li>isTypedArray: Checks whether a value is any typed array (<code>Uint8Array</code>, <code>Float32Array</code>, etc.).</li> <li>isWeakMap: Checks whether a value is a <code>WeakMap</code> instance.</li> <li>isWeakSet: Checks whether a value is a <code>WeakSet</code> instance.</li> </ul> <p>Each helper is pure, predictable, and safe to use in branching logic or before normalization.</p>"},{"location":"reference/type-guards/collections/is-map/","title":"isMap","text":"<p>Checks whether a value is a Map.</p> <p>This helper performs a strict instanceof check and never throws or mutates input. It accepts native <code>Map</code> instances, <code>Map</code> subclasses, and wrapper objects created with <code>Object(...)</code>.</p>"},{"location":"reference/type-guards/collections/is-map/#signature","title":"Signature","text":"<pre><code>function isMap&lt;K = unknown, V = unknown&gt;(value: unknown): value is Map&lt;K, V&gt;\n</code></pre>"},{"location":"reference/type-guards/collections/is-map/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a Map instance to return <code>true</code>."},{"location":"reference/type-guards/collections/is-map/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a <code>Map</code>.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/collections/is-map/#examples","title":"Examples","text":"<pre><code>isMap(new Map())          // true\nisMap(new Map([['a', 1]]))// true\nisMap(Object(new Map()))  // true\n\nisMap({})                 // false\nisMap([])                 // false\nisMap(null)               // false\n</code></pre>"},{"location":"reference/type-guards/collections/is-map/#notes","title":"Notes","text":"<ul> <li>This helper intentionally accepts <code>Map</code> wrapper objects because JavaScript treats them as genuine <code>Map</code> instances.</li> <li>It does not treat plain objects or array\u2011likes as Maps.</li> <li>Use <code>validateMap</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/collections/is-map/#next-up","title":"Next up","text":"<p>isSet</p>"},{"location":"reference/type-guards/collections/is-set/","title":"isSet","text":"<p>Checks whether a value is a Set.</p> <p>This helper performs a strict <code>instanceof</code> check and never throws or mutates input. It accepts native Set instances, Set subclasses, and wrapper objects created with <code>Object(...)</code>.</p>"},{"location":"reference/type-guards/collections/is-set/#signature","title":"Signature","text":"<pre><code>function isSet&lt;T = unknown&gt;(value: unknown): value is Set&lt;T&gt;\n</code></pre> <p>Parameters</p> Name Data type Description value <code>unknown</code> The value to check. Must be a Set instance to return <code>true</code>."},{"location":"reference/type-guards/collections/is-set/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a Set.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/collections/is-set/#examples","title":"Examples","text":"<pre><code>isSet(new Set())          // true\nisSet(new Set([1, 2, 3])) // true\nisSet(Object(new Set()))  // true\n\nisSet({})                 // false\nisSet([])                 // false\nisSet(null)               // false\n</code></pre>"},{"location":"reference/type-guards/collections/is-set/#notes","title":"Notes","text":"<ul> <li>This helper intentionally accepts <code>Set</code> wrapper objects because JavaScript treats them as genuine <code>Set</code> instances.</li> <li>It does not treat plain objects or array\u2011likes as Sets.</li> <li>Use <code>validateSet</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/collections/is-set/#next-up","title":"Next up","text":"<p>isTypedArray</p>"},{"location":"reference/type-guards/collections/is-typed-array/","title":"isTypedArray","text":"<p>Checks whether a value is a TypedArray. This includes all built\u2011in typed array types such as <code>Uint8Array</code>, <code>Float32Array</code>, and <code>BigInt64Array</code>. You may optionally enforce a specific <code>TypedArray</code> constructor.</p> <p>This helper never throws and never mutates input.</p>"},{"location":"reference/type-guards/collections/is-typed-array/#signature","title":"Signature","text":"<pre><code>function isTypedArray&lt;T extends TypedArray = TypedArray&gt;(\n    value: unknown,\n    expected?: { new (...args: unknown[]): T },\n): value is T\n</code></pre>"},{"location":"reference/type-guards/collections/is-typed-array/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a <code>TypedArray</code> to return <code>true</code>. expected <code>constructor</code> Optional. If provided, the value must be an instance of this specific <code>TypedArray</code> type."},{"location":"reference/type-guards/collections/is-typed-array/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a <code>TypedArray</code>.</li> <li><code>true</code>: If the value is a <code>TypedArray</code> and matches the expected type.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/collections/is-typed-array/#examples","title":"Examples","text":"<pre><code>isTypedArray(new Uint8Array())         // true\nisTypedArray(new Float32Array())       // true\nisTypedArray(new Uint8Array(), Uint8Array) // true\nisTypedArray(new Uint8Array(), Float32Array) // false\n\nisTypedArray([])                       // false\nisTypedArray(new DataView(...))        // false\nisTypedArray(null)                     // false\n</code></pre>"},{"location":"reference/type-guards/collections/is-typed-array/#notes","title":"Notes","text":"<ul> <li>This helper uses <code>ArrayBuffer.isView</code> and excludes <code>DataView</code>, matching the ECMAScript definition of <code>TypedArray</code>.</li> <li>It accepts <code>TypedArray</code> subclasses and wrapper objects.</li> <li>Use <code>validateTypedArray</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/collections/is-typed-array/#next-up","title":"Next up","text":"<p>isWeakMap</p>"},{"location":"reference/type-guards/collections/is-weak-map/","title":"isWeakMap","text":"<p>Checks whether a value is a WeakMap.</p> <p>This helper performs a strict <code>instanceof</code> check and never throws or mutates input. It accepts native <code>WeakMap</code> instances, <code>WeakMap</code> subclasses, and wrapper objects created with <code>Object(...)</code>.</p>"},{"location":"reference/type-guards/collections/is-weak-map/#signature","title":"Signature","text":"<pre><code>function isWeakMap&lt;K extends object = object, V = unknown&gt;(\n    value: unknown,\n): value is WeakMap&lt;K, V&gt;\n</code></pre>"},{"location":"reference/type-guards/collections/is-weak-map/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a WeakMap instance to return <code>true</code>"},{"location":"reference/type-guards/collections/is-weak-map/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a WeakMap.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/collections/is-weak-map/#examples","title":"Examples","text":"<pre><code>isWeakMap(new WeakMap())          // true\nisWeakMap(Object(new WeakMap()))  // true\n\nisWeakMap(new Map())              // false\nisWeakMap({})                     // false\nisWeakMap(null)                   // false\n</code></pre>"},{"location":"reference/type-guards/collections/is-weak-map/#notes","title":"Notes","text":"<ul> <li>This helper intentionally accepts <code>WeakMap</code> wrapper objects because JavaScript treats them as genuine <code>WeakMap</code> instances.</li> <li>It does not treat plain objects or Maps as WeakMaps.</li> <li>Use <code>validateWeakMap</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/collections/is-weak-map/#next-up","title":"Next up","text":"<p>isWeakSet</p>"},{"location":"reference/type-guards/collections/is-weak-set/","title":"isWeakSet","text":"<p>Checks whether a value is a WeakSet.</p> <p>This helper performs a strict <code>instanceof</code> check and never throws or mutates input. It accepts native <code>WeakSet</code> instances, <code>WeakSet</code> subclasses, and wrapper objects created with <code>Object(...)</code>.</p>"},{"location":"reference/type-guards/collections/is-weak-set/#signature","title":"Signature","text":"<pre><code>function isWeakSet&lt;T extends object = object&gt;(\n    value: unknown,\n): value is WeakSet&lt;T&gt;\n</code></pre>"},{"location":"reference/type-guards/collections/is-weak-set/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a WeakSet instance to return <code>true</code>."},{"location":"reference/type-guards/collections/is-weak-set/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a WeakSet.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/collections/is-weak-set/#examples","title":"Examples","text":"<pre><code>isWeakSet(new WeakSet())          // true\nisWeakSet(Object(new WeakSet()))  // true\n\nisWeakSet(new Set())              // false\nisWeakSet({})                     // false\nisWeakSet(null)                   // false\n</code></pre>"},{"location":"reference/type-guards/collections/is-weak-set/#notes","title":"Notes","text":"<ul> <li>This helper intentionally accepts <code>WeakSet</code> wrapper objects because JavaScript treats them as genuine <code>WeakSet</code> instances.</li> <li>It does not treat plain objects or Sets as WeakSets.</li> <li>Use <code>validateWeakSet</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/collections/is-weak-set/#next-up","title":"Next up","text":"<p>This is the final topic for collections. In the next section, we'll cover semantic type guards.</p> <p>Semantic</p>"},{"location":"reference/type-guards/primitives/","title":"Overview","text":"<p>Primitive type guards check whether a value is one of JavaScript\u2019s built\u2011in primitive types. They return simple booleans, never throw, and never mutate input.</p> <ul> <li>isBigInteger: Checks whether a value is a <code>bigint</code> primitive.</li> <li>isBoolean: Checks whether a value is a boolean.</li> <li>isFiniteNumber: Checks whether a value is a finite number.</li> <li>isInteger: Checks whether a value is an integer.</li> <li>isNonEmptyString: Checks whether a value is a non\u2011empty string.</li> <li>isNonNegativeNumber: Checks whether a value is a non\u2011negative number.</li> <li>isNull: Checks whether a value is <code>null</code>.</li> <li>isNullOrUndefined: Checks whether a value is <code>null</code> or <code>undefined</code>.</li> <li>isNumber: Checks whether a value is a number.</li> <li>isPositiveInteger: Checks whether a value is a positive integer.</li> <li>isSafeInteger: Checks whether a value is a safe integer.</li> <li>isString: Checks whether a value is a string.</li> <li>isSymbol: Checks whether a value is a symbol.</li> <li>isUndefined: Checks whether a value is <code>undefined</code>.</li> </ul> <p>All primitive guards are pure, predictable, and safe to use before normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-big-integer/","title":"isBigInteger","text":"<p>Checks whether a value is a bigint: A primitive numeric type that represents integers of arbitrary precision.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm bigint types before running normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-big-integer/#signature","title":"Signature","text":"<pre><code>function isBigInteger(value: unknown): value is bigint\n</code></pre>"},{"location":"reference/type-guards/primitives/is-big-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Returns <code>true</code> only for bigint primitives."},{"location":"reference/type-guards/primitives/is-big-integer/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a bigint.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-big-integer/#examples","title":"Examples","text":"<pre><code>isBigInteger(10n)                     // true\nisBigInteger(999999999999999999n)     // true\n\nisBigInteger(10)                      // false\nisBigInteger(3.14)                    // false\nisBigInteger(NaN)                     // false\nisBigInteger(\"123\")                   // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-big-integer/#notes","title":"Notes","text":"<ul> <li>This helper does not accept number values, even if they are integers.</li> <li>Use isInteger or isSafeInteger for number-based integer checks.</li> <li>Big integers are always integers; fractional <code>bigint</code> values do not exist.</li> <li>Use <code>normalizeBigInteger</code> if you need to convert values into big integers.</li> <li>Use <code>validateBigInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-big-integer/#next-up","title":"Next up","text":"<p>isBoolean: Checks whether a value is a boolean.</p>"},{"location":"reference/type-guards/primitives/is-boolean/","title":"isBoolean","text":"<p>Checks whether a value is a boolean.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm boolean types before running normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-boolean/#signature","title":"Signature","text":"<pre><code>function isBoolean(value: unknown): value is boolean\n</code></pre>"},{"location":"reference/type-guards/primitives/is-boolean/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> This helper performs a strict <code>typeof</code> check and only returns <code>true</code> for primitive boolean values."},{"location":"reference/type-guards/primitives/is-boolean/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a boolean.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-boolean/#examples","title":"Examples","text":"<pre><code>isBoolean(true)        // true\nisBoolean(false)       // true\nisBoolean(0)           // false\nisBoolean(\"true\")      // false\nisBoolean(null)        // false\nisBoolean(undefined)   // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-boolean/#notes","title":"Notes","text":"<ul> <li>This helper does not coerce truthy or falsy values.</li> <li>Use <code>normalizeBoolean</code> if you need to convert values into booleans.</li> <li>Use <code>validateBoolean</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-boolean/#next-up","title":"Next up","text":"<p>isFiniteNumber</p>"},{"location":"reference/type-guards/primitives/is-finite-number/","title":"isFiniteNumber","text":"<p>Checks whether a value is a finite primitive number. A finite number is a number primitive that is not <code>NaN</code>, <code>Infinity</code>, or <code>-Infinity</code>.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm that a value is suitable for arithmetic, normalization, or any domain where numeric finiteness is required.</p>"},{"location":"reference/type-guards/primitives/is-finite-number/#signature","title":"Signature","text":"<pre><code>function isFiniteNumber(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/primitives/is-finite-number/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a finite primitive number to return <code>true</code>."},{"location":"reference/type-guards/primitives/is-finite-number/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a finite primitive number.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-finite-number/#examples","title":"Examples","text":"<pre><code>isFiniteNumber(0)        // true\nisFiniteNumber(3.14)     // true\nisFiniteNumber(-100)     // true\n\nisFiniteNumber(NaN)      // false\nisFiniteNumber(Infinity) // false\n\nisFiniteNumber(\"123\")    // false\nisFiniteNumber(1n)       // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-finite-number/#notes","title":"Notes","text":"<ul> <li>This helper is stricter than isNumber, which accepts <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code>.</li> <li>Wrapper objects (for example, <code>new Number(5)</code>) are rejected because they are not number primitives.</li> <li>Use isInteger if you need to confirm integer values.</li> <li>Use <code>normalizeFiniteNumber</code> if you need to coerce values into finite numbers.</li> <li>Use <code>validateFiniteNumber</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-finite-number/#next-up","title":"Next up","text":"<p>isInteger</p>"},{"location":"reference/type-guards/primitives/is-integer/","title":"isInteger","text":"<p>Checks whether a value is a finite integer.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm integer types before running normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-integer/#signature","title":"Signature","text":"<pre><code>function isInteger(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/primitives/is-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. This helper performs a strict <code>typeof</code> check and only returns <code>true</code> for finite integers."},{"location":"reference/type-guards/primitives/is-integer/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a finite integer.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-integer/#examples","title":"Examples","text":"<pre><code>isInteger(42)          // true\nisInteger(0)           // true\nisInteger(-10)         // true\nisInteger(3.14)        // false\nisInteger(NaN)         // false\nisInteger(Infinity)    // false\nisInteger(\"123\")       // false\nisInteger(null)        // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-integer/#notes","title":"Notes","text":"<ul> <li>This helper uses <code>Number.isInteger</code> internally, which rejects <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code>.</li> <li>BigInt values are not considered integers by this helper. Use isBigInteger for BigInt checks.</li> <li>Use <code>normalizeInteger</code> if you need to convert values into integers.</li> <li>Use <code>validateInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-integer/#next-up","title":"Next up","text":"<p>isNonEmptyString</p>"},{"location":"reference/type-guards/primitives/is-non-empty-string/","title":"isNonEmptyString","text":"<p>Checks whether a value is a primitive, non\u2011empty string. This helper never throws and never mutates input. It performs a strict <code>typeof</code> check and does not trim, coerce, or normalize the value. Whitespace and zero\u2011width characters count as non\u2011empty. <code>String</code> objects (for example, <code>new String(\"hello\")</code>) return <code>false</code>.</p>"},{"location":"reference/type-guards/primitives/is-non-empty-string/#signature","title":"Signature","text":"<pre><code>function isNonEmptyString(value: unknown): value is string\n</code></pre>"},{"location":"reference/type-guards/primitives/is-non-empty-string/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a primitive string with length &gt; 0 to return true."},{"location":"reference/type-guards/primitives/is-non-empty-string/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a primitive string with length greater than 0.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-non-empty-string/#examples","title":"Examples","text":"<pre><code>isNonEmptyString(\"hello\")            // true\nisNonEmptyString(\" \")                // true (whitespace counts as non-empty)\nisNonEmptyString(\"\\u200B\")           // true (zero-width space counts as non-empty)\nisNonEmptyString(\"\")                 // false\nisNonEmptyString(123)                // false\nisNonEmptyString(null)               // false\nisNonEmptyString(undefined)          // false\nisNonEmptyString(new String(\"x\"))    // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-non-empty-string/#notes","title":"Notes","text":"<ul> <li>This helper does not trim whitespace.</li> <li>Zero\u2011width characters still count as non\u2011empty.</li> <li>Returns <code>false</code> for String objects (e.g., <code>new String(\"x\")</code>).</li> <li>Use <code>normalizeNonEmptyString</code> if you need trimming and conversion.</li> <li>Use <code>validateNonEmptyString</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-non-empty-string/#next-up","title":"Next up","text":"<p>isNonNegativeNumber</p>"},{"location":"reference/type-guards/primitives/is-non-negative-number/","title":"isNonNegativeNumber","text":"<p>Checks whether a value is a non\u2011negative number. A non\u2011negative number is defined as a finite number greater than or equal to zero. Fractional values are allowed.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm that a value is suitable for ranges, durations, sizes, or any domain where zero or positive numeric values are valid.</p>"},{"location":"reference/type-guards/primitives/is-non-negative-number/#signature","title":"Signature","text":"<pre><code>function isNonNegativeNumber(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/primitives/is-non-negative-number/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a finite number greater than or equal to zero to return <code>true</code>."},{"location":"reference/type-guards/primitives/is-non-negative-number/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a finite number greater than or equal to zero.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-non-negative-number/#examples","title":"Examples","text":"<pre><code>isNonNegativeNumber(0)        // true\nisNonNegativeNumber(3.14)     // true\nisNonNegativeNumber(100)      // true\n\nisNonNegativeNumber(-1)       // false\nisNonNegativeNumber(NaN)      // false\nisNonNegativeNumber(Infinity) // false\n\nisNonNegativeNumber(\"0\")      // false\nisNonNegativeNumber(0n)       // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-non-negative-number/#notes","title":"Notes","text":"<ul> <li>This helper does not coerce strings or other types into numbers.</li> <li>Use <code>normalizeNonNegativeNumber</code> if you need coercion or fallback behavior.</li> <li>Use <code>validateNonNegativeNumber</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> <li>Big integers are intentionally rejected to avoid silent cross\u2011type numeric behavior.</li> </ul>"},{"location":"reference/type-guards/primitives/is-non-negative-number/#next-up","title":"Next up","text":"<p>isNullOrUndefined</p>"},{"location":"reference/type-guards/primitives/is-null-or-undefined/","title":"isNullOrUndefined","text":"<p>Checks whether a value is null or undefined.</p> <p>This helper performs strict equality checks and never throws or mutates input. Use it when you need to confirm that a value is explicitly missing before running normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-null-or-undefined/#signature","title":"Signature","text":"<pre><code>function isNullOrUndefined(value: unknown): value is null | undefined\n</code></pre>"},{"location":"reference/type-guards/primitives/is-null-or-undefined/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Returns <code>true</code> only when the value is exactly <code>null</code> or <code>undefined</code>."},{"location":"reference/type-guards/primitives/is-null-or-undefined/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is null or undefined.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-null-or-undefined/#examples","title":"Examples","text":"<pre><code>isNullOrUndefined(null)        // true\nisNullOrUndefined(undefined)   // true\n\nisNullOrUndefined(0)           // false\nisNullOrUndefined('')          // false\nisNullOrUndefined({})          // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-null-or-undefined/#notes","title":"Notes","text":"<ul> <li>This helper is useful when distinguishing \"missing\" from \"present but falsy\".</li> <li>Use isNull or isUndefined if you need to check for one specific case.</li> <li>Use <code>normalizeNullish</code> if you need to convert nullish values into defaults.</li> <li>Use <code>validateNullish</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-null-or-undefined/#next-up","title":"Next up","text":"<p>isNull</p>"},{"location":"reference/type-guards/primitives/is-null/","title":"isNull","text":"<p>Checks whether a value is null.</p> <p>This helper performs a strict equality check and never throws or mutates input. Use it when you need to confirm that a value is explicitly <code>null</code> before running normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-null/#signature","title":"Signature","text":"<pre><code>function isNull(value: unknown): value is null\n</code></pre>"},{"location":"reference/type-guards/primitives/is-null/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. This helper returns <code>true</code> only when the value is exactly <code>null</code>."},{"location":"reference/type-guards/primitives/is-null/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is null.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-null/#examples","title":"Examples","text":"<pre><code>isNull(null)        // true\n\nisNull(undefined)   // false\nisNull(0)           // false\nisNull('')          // false\nisNull({})          // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-null/#notes","title":"Notes","text":"<ul> <li>This helper does not treat <code>undefined</code> as <code>null</code>. Use isNullOrUndefined if you need to check for both.</li> <li>Use <code>normalizeNull</code> if you need to convert values into <code>null</code>.</li> <li>Use <code>validateNull</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-null/#next-up","title":"Next up","text":"<p>isNumber</p>"},{"location":"reference/type-guards/primitives/is-number/","title":"isNumber","text":"<p>Checks whether a value is a primitive number. This helper performs a strict <code>typeof</code> check and does not enforce finiteness.</p> <p>It accepts <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> because they are still valid number primitives in JavaScript. This helper never throws and never mutates input.</p>"},{"location":"reference/type-guards/primitives/is-number/#signature","title":"Signature","text":"<pre><code>function isNumber(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/primitives/is-number/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. This helper returns <code>true</code> only for primitive numbers."},{"location":"reference/type-guards/primitives/is-number/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a primitive number.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-number/#examples","title":"Examples","text":"<pre><code>isNumber(42)          // true\nisNumber(0)           // true\nisNumber(-3.14)       // true\nisNumber(NaN)         // true\nisNumber(Infinity)    // true\n\nisNumber(\"123\")       // false\nisNumber(null)        // false\nisNumber(1n)          // false\nisNumber(new Number(5)) // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-number/#notes","title":"Notes","text":"<ul> <li>This helper does not check for finiteness. Use isFiniteNumber if you need to reject <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code>.</li> <li>Use isInteger if you need to confirm integer values.</li> <li>Use <code>normalizeNumber</code> if you need to convert values into numbers.</li> <li>Use <code>validateNumber</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-number/#next-up","title":"Next up","text":"<p>isPositiveInteger</p>"},{"location":"reference/type-guards/primitives/is-positive-integer/","title":"isPositiveInteger","text":"<p>Checks whether a value is a positive integer. A positive integer is defined as a finite number with no fractional component and greater than zero.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm that a value is suitable for count\u2011based operations, array lengths, pagination, or any domain where only strictly positive whole numbers are valid.</p>"},{"location":"reference/type-guards/primitives/is-positive-integer/#signature","title":"Signature","text":"<pre><code>function isPositiveInteger(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/primitives/is-positive-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a finite integer greater than zero to return <code>true</code>."},{"location":"reference/type-guards/primitives/is-positive-integer/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a finite integer greater than zero.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-positive-integer/#examples","title":"Examples","text":"<pre><code>isPositiveInteger(1)        // true\nisPositiveInteger(42)       // true\n\nisPositiveInteger(0)        // false\nisPositiveInteger(-1)       // false\nisPositiveInteger(1.5)      // false\nisPositiveInteger(NaN)      // false\nisPositiveInteger(Infinity) // false\n\nisPositiveInteger(\"1\")      // false\nisPositiveInteger(1n)       // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-positive-integer/#notes","title":"Notes","text":"<ul> <li>This helper does not coerce strings or other types into numbers.</li> <li>Use <code>normalizePositiveInteger</code> if you need coercion or fallback behavior.</li> <li>Use <code>validatePositiveInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> <li>Big integers are intentionally rejected to avoid silent cross\u2011type numeric behavior.</li> </ul>"},{"location":"reference/type-guards/primitives/is-positive-integer/#next-up","title":"Next up","text":"<p>isSafeInteger</p>"},{"location":"reference/type-guards/primitives/is-safe-integer/","title":"isSafeInteger","text":"<p>Checks whether a value is a safe integer. A safe integer is a finite integer whose absolute value does not exceed <code>Number.MAX_SAFE_INTEGER</code>.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm that a value is suitable for precise integer arithmetic, indexing, or any domain where JavaScript\u2019s integer precision guarantees matter.</p>"},{"location":"reference/type-guards/primitives/is-safe-integer/#signature","title":"Signature","text":"<pre><code>function isSafeInteger(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/primitives/is-safe-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a finite integer with a safe range to return <code>true</code>."},{"location":"reference/type-guards/primitives/is-safe-integer/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code> if the value is a finite integer within the safe integer range.</li> <li><code>false</code> otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-safe-integer/#examples","title":"Examples","text":"<pre><code>isSafeInteger(0)                        // true\nisSafeInteger(42)                       // true\nisSafeInteger(Number.MAX_SAFE_INTEGER)  // true\n\nisSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\nisSafeInteger(1.5)                         // false\nisSafeInteger(NaN)                          // false\n\nisSafeInteger(\"1\")                          // false\nisSafeInteger(1n)                           // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-safe-integer/#notes","title":"Notes","text":"<ul> <li>This helper does not coerce strings or other types into numbers.</li> <li>Use <code>normalizeSafeInteger</code> if you need coercion or fallback behavior.</li> <li>Use <code>validateSafeInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> <li>Big integers are intentionally rejected to avoid silent cross\u2011type numeric behavior.</li> <li>Safe integers are essential when you need guaranteed precision in JavaScript.</li> </ul>"},{"location":"reference/type-guards/primitives/is-safe-integer/#next-up","title":"Next up","text":"<p>isString</p>"},{"location":"reference/type-guards/primitives/is-string/","title":"isString","text":"<p>Checks whether a value is a primitive string. This helper never throws and never mutates input. It performs a strict <code>typeof</code> check and does not coerce values.</p>"},{"location":"reference/type-guards/primitives/is-string/#signature","title":"Signature","text":"<pre><code>function isString(value: unknown): value is string\n</code></pre>"},{"location":"reference/type-guards/primitives/is-string/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a string (primitive string) to return <code>true</code>."},{"location":"reference/type-guards/primitives/is-string/#returns","title":"Returns","text":"<ul> <li><code>true</code> if the value is a primitive string.</li> <li><code>false</code> otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-string/#examples","title":"Examples","text":"<pre><code>isString(\"hello\")               // true\nisString(\"\")                    // true\nisString(123)                   // false\nisString(null)                  // false\nisString(undefined)             // false\nisString({})                    // false\nisString([])                    // false\nisString(new String(\"hello\"))   // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-string/#notes","title":"Notes","text":"<ul> <li>This helper does not trim or modify the value.</li> <li>This helper returns <code>false</code> for String objects (for example, <code>new String(\"x\")</code>).</li> <li>Use <code>isNonEmptyString</code> if you need to ensure the string is not empty.</li> <li>Use <code>normalizeString</code> if you need to convert values into strings.</li> </ul>"},{"location":"reference/type-guards/primitives/is-string/#next-up","title":"Next up","text":"<p>isSymbol</p>"},{"location":"reference/type-guards/primitives/is-symbol/","title":"isSymbol","text":"<p>Checks whether a value is a symbol. A symbol is a primitive value created using the <code>Symbol</code> function.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm symbol types before running normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-symbol/#signature","title":"Signature","text":"<pre><code>function isSymbol(value: unknown): value is symbol\n</code></pre>"},{"location":"reference/type-guards/primitives/is-symbol/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. This helper returns true only for symbol primitives."},{"location":"reference/type-guards/primitives/is-symbol/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code> if the value is a symbol.</li> <li><code>false</code> otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-symbol/#examples","title":"Examples","text":"<pre><code>isSymbol(Symbol())          // true\nisSymbol(Symbol('id'))      // true\nisSymbol(Symbol.iterator)   // true\n\nisSymbol(Object(Symbol()))  // false\nisSymbol(\"abc\")             // false\nisSymbol(123)               // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-symbol/#notes","title":"Notes","text":"<ul> <li>This helper performs a strict <code>typeof</code> check and does not accept <code>Symbol</code> wrapper objects.</li> <li>Use <code>normalizeSymbol</code> if you need to convert values into symbols.</li> <li>Use <code>validateSymbol</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-symbol/#next-up","title":"Next up","text":"<p>isUndefined</p>"},{"location":"reference/type-guards/primitives/is-undefined/","title":"isUndefined","text":"<p>Checks whether a value is undefined. This helper performs a strict equality check and never throws or mutates input.</p> <p>Use it when you need to confirm that a value is explicitly <code>undefined</code> before running normalization or validation.</p>"},{"location":"reference/type-guards/primitives/is-undefined/#signature","title":"Signature","text":"<pre><code>function isUndefined(value: unknown): value is undefined\n</code></pre>"},{"location":"reference/type-guards/primitives/is-undefined/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Returns <code>true</code> only when the value is exactly <code>undefined</code>."},{"location":"reference/type-guards/primitives/is-undefined/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is <code>undefined</code>.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/primitives/is-undefined/#examples","title":"Examples","text":"<pre><code>isUndefined(undefined)   // true\n\nisUndefined(null)        // false\nisUndefined(0)           // false\nisUndefined('')          // false\nisUndefined({})          // false\n</code></pre>"},{"location":"reference/type-guards/primitives/is-undefined/#notes","title":"Notes","text":"<ul> <li>This helper does not treat <code>null</code> as <code>undefined</code>. Use isNullOrUndefined if you need to check for both.</li> <li>Use <code>normalizeUndefined</code> if you need to convert values into <code>undefined</code>.</li> <li>Use <code>validateUndefined</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/primitives/is-undefined/#next-up","title":"Next up","text":"<p>This is the final topic for primitives. In the next section, we'll cover structural type guards.</p> <p>Structural</p>"},{"location":"reference/type-guards/protocols/","title":"Overview","text":"<p>Protocol type guards check whether a value implements a specific JavaScript protocol. These helpers validate behavior rather than structure, returning simple booleans with no side effects.</p> <ul> <li>isAsyncIterable: Checks whether a value implements the async iteration protocol (<code>Symbol.asyncIterator</code>).</li> <li>isIterable: Checks whether a value implements the iteration protocol (<code>Symbol.iterator</code>).</li> <li>isPromise: Checks whether a value is a <code>Promise</code> or promise\u2011like object.</li> </ul> <p>All protocol guards are pure, predictable, and safe to use before normalization or validation.</p>"},{"location":"reference/type-guards/protocols/is-async-iterable/","title":"isAsyncIterable","text":"<p>Checks whether a value is asynchronously iterable. A value is async iterable if it is not <code>null</code> or <code>undefined</code> and has a callable [Symbol.asyncIterator] method. This matches the behavior of <code>await</code> and other async iteration constructs.</p>"},{"location":"reference/type-guards/protocols/is-async-iterable/#signature","title":"Signature","text":"<pre><code>function isAsyncIterable&lt;T = unknown&gt;(value: unknown): value is AsyncIterable&lt;T&gt;\n</code></pre>"},{"location":"reference/type-guards/protocols/is-async-iterable/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must implement the async iterable protocol to return <code>true</code>."},{"location":"reference/type-guards/protocols/is-async-iterable/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is async iterable.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/protocols/is-async-iterable/#examples","title":"Examples","text":"<pre><code>async function* gen() { yield 1 }\nisAsyncIterable(gen())          // true\n\nisAsyncIterable([])             // false\nisAsyncIterable('abc')          // false\nisAsyncIterable(null)           // false\n</code></pre>"},{"location":"reference/type-guards/protocols/is-async-iterable/#notes","title":"Notes","text":"<ul> <li>This helper checks only for the presence of a callable <code>[Symbol.asyncIterator]</code> method.</li> <li>It does not attempt to call the async iterator.</li> <li>Sync iterables are not considered async iterables.</li> <li>Use <code>validateAsyncIterable</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/protocols/is-async-iterable/#next-up","title":"Next up","text":"<p>isIterable</p>"},{"location":"reference/type-guards/protocols/is-iterable/","title":"isIterable","text":"<p>Checks whether a value is iterable. A value is iterable if it is not <code>null</code> or <code>undefined</code> and has a callable <code>[Symbol.iterator]</code> method. This matches the behavior of <code>for...of</code>, spread syntax, and <code>Array.from</code>.</p>"},{"location":"reference/type-guards/protocols/is-iterable/#signature","title":"Signature","text":"<pre><code>function isIterable&lt;T = unknown&gt;(value: unknown): value is Iterable&lt;T&gt;\n</code></pre> <p>Parameters</p> Name Data type Description value <code>unknown</code> The value to check. Must implement the iterable protocol to return <code>true</code>."},{"location":"reference/type-guards/protocols/is-iterable/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is iterable.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/protocols/is-iterable/#examples","title":"Examples","text":"<pre><code>isIterable([1, 2, 3])        // true\nisIterable('abc')            // true\nisIterable(new Set())        // true\n\nisIterable({})               // false\nisIterable(123)              // false\nisIterable(null)             // false\n</code></pre>"},{"location":"reference/type-guards/protocols/is-iterable/#notes","title":"Notes","text":"<ul> <li>This helper checks only for the presence of a callable <code>[Symbol.iterator]</code> method.</li> <li>Array-like objects (objects with numeric length but without a <code>[Symbol.iterator]</code> method) are not considered iterable by this helper.</li> <li>It does not attempt to call the iterator.</li> <li>It does not treat array\u2011like objects as iterable unless they implement the iterator protocol.</li> <li>Use <code>validateIterable</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/protocols/is-iterable/#next-up","title":"Next up","text":"<p>isPromise</p>"},{"location":"reference/type-guards/protocols/is-promise/","title":"isPromise","text":"<p>Checks whether a value is a Promise.</p> <p>This helper performs a strict <code>instanceof</code> check and never throws or mutates input. It accepts native <code>Promise</code> instances and <code>Promise</code> subclasses, but does not treat arbitrary \"thenables\" as <code>Promises</code>.</p>"},{"location":"reference/type-guards/protocols/is-promise/#signature","title":"Signature","text":"<pre><code>function isPromise(value: unknown): value is Promise&lt;unknown&gt;\n</code></pre>"},{"location":"reference/type-guards/protocols/is-promise/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Returns <code>true</code> only if the value is a native <code>Promise</code> instance or a subclass of <code>Promise</code>."},{"location":"reference/type-guards/protocols/is-promise/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a <code>Promise</code>.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/protocols/is-promise/#examples","title":"Examples","text":"<pre><code>isPromise(Promise.resolve())     // true\nisPromise(new Promise(() =&gt; {})) // true\n\nisPromise({ then() {} })         // false\nisPromise('promise')             // false\nisPromise(null)                  // false\n</code></pre>"},{"location":"reference/type-guards/protocols/is-promise/#notes","title":"Notes","text":"<ul> <li>This helper intentionally does not treat \"thenables\" as <code>Promises</code>.</li> <li>It accepts <code>Promise</code> subclasses.</li> <li>Use <code>normalizePromise</code> if you need to coerce values into Promises.</li> <li>Use <code>validatePromise</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/protocols/is-promise/#next-up","title":"Next up","text":"<p>This is the final reference topic. </p>"},{"location":"reference/type-guards/semantic/","title":"Overview","text":"<p>Semantic type guards check whether a value represents a specific meaningful concept in JavaScript: such as dates, errors, timestamps, or JSON\u2011compatible data. These helpers validate semantics rather than primitive type or structure, returning simple booleans with no side effects.</p> <ul> <li>isDate: Checks whether a value is a <code>Date</code> instance.</li> <li>isEnumValue: Checks whether a value is a valid member of a TypeScript enum.</li> <li>isError: Checks whether a value is an <code>Error</code> instance.</li> <li>isFunction: Checks whether a value is a function.</li> <li>isJSON: Checks whether a value is valid JSON data (objects, arrays, or JSON primitives).</li> <li>isPort: Checks whether a value is a valid TCP/UDP port number.</li> <li>isRegExp: Checks whether a value is a <code>RegExp</code> instance.</li> <li>isTimestamp: Checks whether a value is a valid Unix timestamp (milliseconds since epoch).</li> </ul> <p>All semantic guards are pure, predictable, and safe to use before normalization or validation.</p>"},{"location":"reference/type-guards/semantic/is-date/","title":"isDate","text":"<p>Checks whether a value is a valid Date instance.</p> <p>This helper verifies two things:</p> <ol> <li>The value is actually a <code>Date</code> object (<code>instanceof Date</code>).</li> <li>The internal timestamp is valid (<code>getTime()</code> is not <code>NaN</code>).</li> </ol> <p>It never throws and never mutates input.</p>"},{"location":"reference/type-guards/semantic/is-date/#signature","title":"Signature","text":"<pre><code>function isDate(value: unknown): value is Date\n</code></pre> Name Data type Description value <code>unknown</code> The value to check. Must be a <code>Date</code> instance with a valid timestamp to return <code>true</code>."},{"location":"reference/type-guards/semantic/is-date/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a Date instance and its timestamp is valid.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/semantic/is-date/#examples","title":"Examples","text":"<pre><code>isDate(new Date())                 // true\nisDate(new Date(\"2020-01-01\"))     // true\n\nisDate(new Date(\"invalid\"))        // false\nisDate(Date.now())                 // false\nisDate(\"2020-01-01\")               // false\nisDate(null)                       // false\nisDate({})                         // false\n</code></pre>"},{"location":"reference/type-guards/semantic/is-date/#notes","title":"Notes","text":"<ul> <li>Invalid <code>Date</code> objects such as <code>new Date(\"invalid\")</code> are rejected because their time value is <code>NaN</code>.</li> <li>This helper does not attempt to parse or coerce values into dates.</li> <li>Use <code>normalizeDate</code> if you need to convert values into <code>Date</code> instances.</li> <li>Use <code>validateDate</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/semantic/is-date/#next-up","title":"Next up","text":"<p>isEnumValue</p>"},{"location":"reference/type-guards/semantic/is-enum-value/","title":"isEnumValue","text":"<p>Checks whether a value is one of the allowed enum values. This helper works with both numeric and string enums.</p> <p>It never throws and never mutates input. Use it when you need to confirm that a value belongs to a specific enum before running normalization or validation.</p>"},{"location":"reference/type-guards/semantic/is-enum-value/#signature","title":"Signature","text":"<pre><code>function isEnumValue&lt;T extends Record&lt;string, unknown&gt;&gt;(\n  enumObject: T,\n  value: unknown\n): value is T[keyof T]\n</code></pre>"},{"location":"reference/type-guards/semantic/is-enum-value/#parameters","title":"Parameters","text":"Name Data type Description enumObject <code>Record&lt;string, unknown&gt;</code> The enum-like object whose values define the allowed set. value <code>unknown</code> The value to check. Must match one of the enum\u2019s values to return <code>true</code>."},{"location":"reference/type-guards/semantic/is-enum-value/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is included in <code>Object.values(enumObject)</code>.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/semantic/is-enum-value/#examples","title":"Examples","text":"<pre><code>enum Color {\n  Red = \"red\",\n  Blue = \"blue\",\n}\n\nisEnumValue(Color, \"red\")     // true\nisEnumValue(Color, \"blue\")    // true\nisEnumValue(Color, \"green\")   // false\nisEnumValue(Color, 123)       // false\n\nenum Status {\n  Active = 1,\n  Disabled = 2,\n}\n\nisEnumValue(Status, 1)        // true\nisEnumValue(Status, 3)        // false\n</code></pre> <p>For numeric enums, TypeScript generates reverse mappings, which means enum keys may also be treated as valid values:</p> <pre><code>enum Status {\n  Active = 1,\n  Disabled = 2,\n}\n\n// [\"Active\", \"Disabled\", 1, 2]\nObject.values(Status)\n\nisEnumValue(Status, \"Active\") // true\n</code></pre>"},{"location":"reference/type-guards/semantic/is-enum-value/#notes","title":"Notes","text":"<ul> <li>Works with both string and numeric enums.</li> <li>Uses <code>Object.values(enumObject).includes(value)</code> internally.</li> <li>Use <code>normalizeEnum</code> if you need to convert values into enum values.</li> <li>Use <code>validateEnum</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/semantic/is-enum-value/#next-up","title":"Next up","text":"<p>isError</p>"},{"location":"reference/type-guards/semantic/is-error/","title":"isError","text":"<p>Checks whether a value is an Error object.</p> <p>This helper performs a strict <code>instanceof</code> check and never throws or mutates input. It accepts all native error types as well as custom error subclasses.</p> <p>Note: <code>isError</code> uses a strict <code>instanceof Error</code> check. This means it may return <code>false</code> for <code>Error</code> objects created in a different execution context (for example, another realm such as an iframe).</p>"},{"location":"reference/type-guards/semantic/is-error/#signature","title":"Signature","text":"<pre><code>function isError(value: unknown): value is Error\n</code></pre>"},{"location":"reference/type-guards/semantic/is-error/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be an <code>Error</code> instance (including subclasses and wrapper objects) to return <code>true</code>."},{"location":"reference/type-guards/semantic/is-error/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is an <code>Error</code>.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/semantic/is-error/#examples","title":"Examples","text":"<pre><code>isError(new Error())          // true\nisError(new TypeError())      // true\nisError(Object(new Error()))  // true\n\nisError({ name: 'Error' })    // false\nisError('Error')              // false\nisError(null)                 // false\n</code></pre>"},{"location":"reference/type-guards/semantic/is-error/#notes","title":"Notes","text":"<ul> <li>This helper accepts wrapper objects because JavaScript treats them as genuine <code>Error</code> instances.</li> <li>It accepts all native error types and custom subclasses.</li> <li>Use <code>normalizeError</code> if you need to convert values into <code>Error</code> objects.</li> <li>Use <code>validateError</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/semantic/is-error/#next-up","title":"Next up","text":"<p>isFunction</p>"},{"location":"reference/type-guards/semantic/is-function/","title":"isFunction","text":"<p>Checks whether a value is a function.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm callable values before running logic that expects a function.</p>"},{"location":"reference/type-guards/semantic/is-function/#signature","title":"Signature","text":"<pre><code>function isFunction(value: unknown): value is Function\n</code></pre> Name Data type Description value <code>unknown</code> The value to check. Must be a function (per JavaScript's <code>typeof</code> semantics), including class constructors, async functions, generator functions, and bound functions."},{"location":"reference/type-guards/semantic/is-function/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a function (including classes, async, generator, and built-in functions).</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/semantic/is-function/#examples","title":"Examples","text":"<pre><code>// Standard functions\nisFunction(function () {})        // true\nisFunction(() =&gt; {})              // true\n\n// Async functions\nisFunction(async function () {})  // true\nisFunction(async () =&gt; {})        // true\n\n// Generator functions\nisFunction(function* () {})       // true\n\n// Class constructors\nclass MyClass {}\nisFunction(MyClass)               // true\n\n// Bound functions\nconst fn = () =&gt; {};\nconst bound = fn.bind(null);\nisFunction(bound)                 // true\n\n// Built-in functions\nisFunction(Math.max)              // true\nisFunction(Promise.resolve)       // true\n\n// Non-functions\nisFunction(123)                   // false\nisFunction('abc')                 // false\nisFunction({})                    // false\nisFunction(null)                  // false\nisFunction(undefined)             // false\nisFunction([])                    // false\nisFunction(Symbol())              // false\n</code></pre>"},{"location":"reference/type-guards/semantic/is-function/#notes","title":"Notes","text":"<ul> <li>Classes are technically functions in JavaScript <code>(typeof class X {} === 'function')</code>, so they return <code>true</code>.</li> <li>Async functions, generator functions, and bound functions are all considered functions by this helper.</li> <li>This helper does not invoke the value; it only checks type.</li> <li>Use <code>normalizeFunction</code> if you need to wrap or coerce values into callable functions.</li> <li>Use <code>validateFunction</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/semantic/is-function/#next-up","title":"Next up","text":"<p>isJSON</p>"},{"location":"reference/type-guards/semantic/is-json/","title":"isJSON","text":"<p>Checks whether a value is a valid JSON value. This helper performs a strict, recursive structural check aligned with the ECMAScript JSON specification. It never throws and never mutates input.</p> <p>A JSON value is one of:</p> <ul> <li><code>null</code>.</li> <li><code>boolean</code>.</li> <li>A finite number (<code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> are not allowed).</li> <li><code>string</code>.</li> <li>An array of JSON values.</li> </ul> <p>Plain objects (<code>{}</code>) whose values are JSON values (objects with custom prototypes, for example, <code>Date</code>, <code>Map</code>, <code>Set</code>, or class instances) are rejected.</p>"},{"location":"reference/type-guards/semantic/is-json/#signature","title":"Signature","text":"<pre><code>function isJSON(value: unknown): value is JSONValue\n</code></pre>"},{"location":"reference/type-guards/semantic/is-json/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must conform to JSON structural rules to return <code>true</code>."},{"location":"reference/type-guards/semantic/is-json/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is JSON\u2011safe.</li> <li><code>false</code>: Otherwise.</li> </ul> <p>Examples</p> <pre><code>isJSON(null)                     // true\nisJSON(true)                     // true\nisJSON(123)                      // true\nisJSON('abc')                    // true\nisJSON([1, 'a', null])           // true\nisJSON({ a: 1, b: [true, null] }) // true\n\nisJSON(NaN)                      // false\nisJSON(Infinity)                 // false\nisJSON(undefined)                // false\nisJSON(() =&gt; {})                 // false\nisJSON(new Date())               // false\nisJSON({ a: undefined })         // false\n\n// Circular references are rejected\nconst arr: unknown[] = [];\narr.push(arr);\nisJSON(arr)                      // false\n\nconst obj: Record&lt;string, unknown&gt; = {};\nobj['self'] = obj;\nisJSON(obj)                       // false\n</code></pre>"},{"location":"reference/type-guards/semantic/is-json/#notes","title":"Notes","text":"<ul> <li>Rejects non\u2011finite numbers (<code>NaN</code>, <code>Infinity</code>).</li> <li>Rejects objects with custom prototypes (including <code>Date</code>, <code>Map</code>, <code>Set</code>, class instances).</li> <li>Rejects functions, symbols, bigint, and <code>undefined</code>.</li> <li>Rejects circular structures.</li> <li>This guard is structural, not behavioral. It does not call <code>JSON.stringify</code>.</li> </ul>"},{"location":"reference/type-guards/semantic/is-json/#next-up","title":"Next up","text":"<p>isPort</p>"},{"location":"reference/type-guards/semantic/is-port/","title":"isPort","text":"<p>Checks whether a value is a valid TCP/UDP port number. A port is defined as an integer between <code>0</code> and <code>65535</code> (inclusive).</p> <p>This helper never throws and never mutates input. It performs strict type checks and does not coerce strings or other values into numbers.</p>"},{"location":"reference/type-guards/semantic/is-port/#signature","title":"Signature","text":"<pre><code>function isPort(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/semantic/is-port/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be an integer between 0 and 65535 (inclusive) to return <code>true</code>."},{"location":"reference/type-guards/semantic/is-port/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is an integer within the valid port range.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/semantic/is-port/#examples","title":"Examples","text":"<pre><code>isPort(0)        // true\nisPort(80)       // true\nisPort(65535)    // true\n\nisPort(-1)       // false\nisPort(70000)    // false\nisPort(3.14)     // false\nisPort(\"80\")     // false\nisPort(null)     // false\n</code></pre>"},{"location":"reference/type-guards/semantic/is-port/#notes","title":"Notes","text":"<ul> <li>This helper does not coerce strings (for example, \"80\" is invalid).</li> <li>This helper requires the value to be a primitive number.</li> <li>Use <code>normalizePort</code> if you need to coerce values into ports.</li> <li>Use <code>validatePort</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/semantic/is-port/#next-up","title":"Next up","text":"<p>isRegExp</p>"},{"location":"reference/type-guards/semantic/is-reg-exp/","title":"isRegExp","text":"<p>Checks whether a value is a regular expression.</p> <p>This helper performs a strict <code>instanceof</code> check and never throws or mutates input. It accepts both RegExp literals and RegExp objects created with <code>new RegExp</code>, including wrapper objects created with <code>Object(...)</code>.</p>"},{"location":"reference/type-guards/semantic/is-reg-exp/#signature","title":"Signature","text":"<pre><code>function isRegExp(value: unknown): value is RegExp\n</code></pre>"},{"location":"reference/type-guards/semantic/is-reg-exp/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a RegExp instance (including wrapper objects) to return <code>true</code>."},{"location":"reference/type-guards/semantic/is-reg-exp/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a <code>RegExp</code>.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/semantic/is-reg-exp/#examples","title":"Examples","text":"<pre><code>isRegExp(/abc/)              // true\nisRegExp(new RegExp('abc'))  // true\nisRegExp(Object(/abc/))      // true\n\nisRegExp('/abc/')            // false\nisRegExp('abc')              // false\nisRegExp(null)               // false\n</code></pre>"},{"location":"reference/type-guards/semantic/is-reg-exp/#notes","title":"Notes","text":"<ul> <li>This helper intentionally accepts <code>RegExp</code> wrapper objects, because JavaScript treats them as genuine <code>RegExp</code> instances.</li> <li>Strings that resemble regex literals (for example, <code>/abc/</code>) are not considered <code>RegExp</code> values.</li> <li>Use <code>normalizeRegExp</code> if you need to convert strings into <code>RegExp</code> objects.</li> <li>Use <code>validateRegExp</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/semantic/is-reg-exp/#next-up","title":"Next up","text":"<p>isTimestamp</p>"},{"location":"reference/type-guards/semantic/is-timestamp/","title":"isTimestamp","text":"<p>Checks whether a value is a Unix timestamp in milliseconds. A timestamp is defined as a finite integer number representing milliseconds since the Unix epoch (<code>1970\u201101\u201101T00:00:00Z</code>).</p> <p>This helper never throws and never mutates input. Use it when you need to confirm timestamp values before running normalization or validation.</p>"},{"location":"reference/type-guards/semantic/is-timestamp/#signature","title":"Signature","text":"<pre><code>function isTimestamp(value: unknown): value is number\n</code></pre>"},{"location":"reference/type-guards/semantic/is-timestamp/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> true"},{"location":"reference/type-guards/semantic/is-timestamp/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a finite integer timestamp.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/semantic/is-timestamp/#examples","title":"Examples","text":"<pre><code>isTimestamp(1700000000000)   // true\nisTimestamp(0)               // true\nisTimestamp(-1000)           // true (pre\u2011epoch)\n\nisTimestamp(3.14)            // false\nisTimestamp(\"1700000000000\") // false\nisTimestamp(NaN)             // false\n</code></pre>"},{"location":"reference/type-guards/semantic/is-timestamp/#notes","title":"Notes","text":"<ul> <li>This helper does not accept fractional numbers or strings.</li> <li>Negative timestamps are valid and represent dates before the Unix epoch.</li> <li>Use <code>normalizeTimestamp</code> if you need to coerce values into timestamps.</li> <li>Use <code>validateTimestamp</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/semantic/is-timestamp/#next-up","title":"Next up","text":"<p>This is the final topic for semantic type guards. In the next section, we'll cover type guards for protocols.</p> <p>Protocols</p>"},{"location":"reference/type-guards/structural/","title":"Overview","text":"<p>Structural type guards check whether a value has a particular object shape. These helpers validate structure rather than primitive type, returning simple booleans with no side effects.</p> <ul> <li>isArray: Checks whether a value is an array.</li> <li>isNonEmptyArray: Checks whether a value is a non\u2011empty array.</li> <li>isObject: Checks whether a value is a non\u2011null object.</li> <li>isPlainObject: Checks whether a value is a plain object with <code>Object.prototype</code>.</li> <li>isRecord: Checks whether a value is a record\u2011like object (non\u2011null, non\u2011array).</li> <li>isTuple: Checks whether a value is a tuple of a specific length.</li> </ul> <p>All structural guards are pure, predictable, and safe to use before normalization or validation.</p>"},{"location":"reference/type-guards/structural/is-array/","title":"isArray","text":"<p>Checks whether a value is an array.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm that a value is an array before running normalization or validation.</p>"},{"location":"reference/type-guards/structural/is-array/#signature","title":"Signature","text":"<pre><code>function isArray(value: unknown): value is unknown[]\n</code></pre>"},{"location":"reference/type-guards/structural/is-array/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The unknown value to check. Must be validated explicitly; no assumptions or coercion are applied."},{"location":"reference/type-guards/structural/is-array/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is an array.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/structural/is-array/#examples","title":"Examples","text":"<pre><code>isArray([])              // true\nisArray([1, 2, 3])       // true\nisArray([\"a\", \"b\"])      // true\n\nisArray({})              // false\nisArray(null)            // false\nisArray(\"hello\")         // false\nisArray(123)             // false\n</code></pre>"},{"location":"reference/type-guards/structural/is-array/#notes","title":"Notes","text":"<ul> <li>This helper uses <code>Array.isArray</code> internally.</li> <li>Use <code>normalizeArray</code> if you need to ensure a value becomes an array.</li> <li>Use <code>validateArray</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/structural/is-array/#next-up","title":"Next up","text":"<p>is-non-empty-array</p>"},{"location":"reference/type-guards/structural/is-non-empty-array/","title":"isNonEmptyArray","text":"<p>Checks whether a value is a non\u2011empty array. This helper performs a strict <code>Array</code> check and verifies that the array contains at least one element.</p> <p>It never throws and never mutates input. Use it when you need to confirm that a value is an array with meaningful content before running normalization or validation.</p>"},{"location":"reference/type-guards/structural/is-non-empty-array/#signature","title":"Signature","text":"<pre><code>function isNonEmptyArray&lt;T = unknown&gt;(value: unknown): value is T[]\n</code></pre>"},{"location":"reference/type-guards/structural/is-non-empty-array/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be an array with at least one element to return <code>true</code>."},{"location":"reference/type-guards/structural/is-non-empty-array/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a non\u2011empty array.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/structural/is-non-empty-array/#examples","title":"Examples","text":"<pre><code>isNonEmptyArray([1])        // true\nisNonEmptyArray(['a'])      // true\n\nisNonEmptyArray([])         // false\nisNonEmptyArray('abc')      // false\nisNonEmptyArray(null)       // false\n</code></pre>"},{"location":"reference/type-guards/structural/is-non-empty-array/#notes","title":"Notes","text":"<ul> <li>This helper does not validate the contents of the array.</li> <li>Use <code>normalizeNonEmptyArray</code> if you need to coerce or default empty arrays.</li> <li>Use <code>validateNonEmptyArray</code> if you need a <code>Result&lt;T[]&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/structural/is-non-empty-array/#next-up","title":"Next up","text":"<p>isObject</p>"},{"location":"reference/type-guards/structural/is-object/","title":"isObject","text":"<p>Checks whether a value is an object, excluding <code>null</code> and arrays.</p> <p>This helper never throws and never mutates input. Use it when you need to confirm that a value is a non\u2011null, non\u2011array object before running normalization or validation.</p>"},{"location":"reference/type-guards/structural/is-object/#signature","title":"Signature","text":"<pre><code>function isObject(value: unknown): value is object\n</code></pre>"},{"location":"reference/type-guards/structural/is-object/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a non\u2011null, non\u2011array object to return <code>true</code>."},{"location":"reference/type-guards/structural/is-object/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is an object, not null, and not an array.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/structural/is-object/#examples","title":"Examples","text":"<pre><code>isObject({})                     // true\nisObject({ a: 1 })               // true\nisObject(Object.create(null))    // true\n\nisObject([])                     // false\nisObject(null)                   // false\nisObject(\"hello\")                // false\nisObject(123)                    // false\n</code></pre>"},{"location":"reference/type-guards/structural/is-object/#notes","title":"Notes","text":"<ul> <li>This helper excludes arrays by design.</li> <li>Use isPlainObject if you need to confirm <code>Object.getPrototypeOf(value) === Object.prototype</code>.</li> <li>Use <code>normalizeObject</code> if you need to ensure the value becomes an object.</li> <li>Use <code>validateObject</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/structural/is-object/#next-up","title":"Next up","text":"<p>isPlainObject</p>"},{"location":"reference/type-guards/structural/is-plain-object/","title":"isPlainObject","text":"<p>Checks whether a value is a plain object. A plain object is one created with <code>{}</code> or <code>new Object()</code>, where the prototype is exactly <code>Object.prototype</code>.</p> <p>This helper excludes <code>null</code>, arrays, class instances, and objects with custom prototypes. It never throws and never mutates input.</p>"},{"location":"reference/type-guards/structural/is-plain-object/#signature","title":"Signature","text":"<pre><code>function isPlainObject(value: unknown): value is object\n</code></pre>"},{"location":"reference/type-guards/structural/is-plain-object/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a non\u2011null object whose prototype is exactly <code>Object.prototype</code> to return <code>true</code>"},{"location":"reference/type-guards/structural/is-plain-object/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a non\u2011null object with <code>Object.prototype</code> as its prototype.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/structural/is-plain-object/#examples","title":"Examples","text":"<pre><code>isPlainObject({})                     // true\nisPlainObject({ a: 1 })               // true\nisPlainObject(new Object())           // true\n\nisPlainObject([])                     // false\nisPlainObject(null)                   // false\nisPlainObject(Object.create(null))    // false\nisPlainObject(new Date())             // false\nisPlainObject(class X {})             // false\nisPlainObject(new (class Y {})())     // false\n</code></pre>"},{"location":"reference/type-guards/structural/is-plain-object/#notes","title":"Notes","text":"<ul> <li>This helper is stricter than isObject. Use <code>isObject</code> if you only need to exclude <code>null</code> and arrays.</li> <li>Use <code>normalizeObject</code> if you need to ensure the value becomes an object.</li> <li>Use <code>validateObject</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/structural/is-plain-object/#next-up","title":"Next up","text":"<p>isRecord</p>"},{"location":"reference/type-guards/structural/is-record/","title":"isRecord","text":"<p>Checks whether a value is a record-like object with string keys.</p> <p>A record is defined as:</p> <ol> <li>A non-null, non-array object.</li> <li>All of its own property keys are strings (symbols are not allowed).</li> <li>Objects with any prototype are accepted, including class instances and objects created with <code>Object.create(null)</code>.</li> </ol> <p>This helper never throws and never mutates input. Use it when you need to confirm that a value is suitable for string-keyed object operations before running normalization or validation.</p>"},{"location":"reference/type-guards/structural/is-record/#signature","title":"Signature","text":"<pre><code>function isRecord(value: unknown): value is Record&lt;string, unknown&gt;\n</code></pre>"},{"location":"reference/type-guards/structural/is-record/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be a non-null, non-array object whose own keys are strings to return <code>true</code>."},{"location":"reference/type-guards/structural/is-record/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a non\u2011null, non\u2011array object.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/structural/is-record/#examples","title":"Examples","text":"<pre><code>isRecord({})                     // true\nisRecord({ a: 1 })               // true\nisRecord(Object.create(null))    // true\nisRecord(new (class X {})())     // true\n\nisRecord([])                     // false\nisRecord(null)                   // false\nisRecord(\"hello\")                // false\nisRecord(123)                    // false\n</code></pre>"},{"location":"reference/type-guards/structural/is-record/#notes","title":"Notes","text":"<ul> <li>This guard is stricter than isObject because it rejects arrays.</li> <li>Use isPlainObject if you also need the prototype to be exactly <code>Object.prototype</code>.</li> <li>Use <code>normalizeRecord</code> if you need to coerce values into records.</li> <li>Use <code>validateRecord</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/structural/is-record/#next-up","title":"Next up","text":"<p>isTuple</p>"},{"location":"reference/type-guards/structural/is-tuple/","title":"isTuple","text":"<p>Checks whether a value is a tuple of a specific structure. A tuple is defined as an array with a fixed length where each element satisfies a corresponding guard.</p> <p>This helper is fully structural and never throws or mutates input.</p>"},{"location":"reference/type-guards/structural/is-tuple/#signature","title":"Signature","text":"<pre><code>function isTuple&lt;\n    const Guards extends readonly ((value: unknown) =&gt; boolean)[]\n&gt;(\n    value: unknown,\n    guards: Guards,\n): value is {\n    [I in keyof Guards]:\n        Guards[I] extends (value: unknown) =&gt; value is infer T ? T : unknown\n}\n</code></pre>"},{"location":"reference/type-guards/structural/is-tuple/#parameters","title":"Parameters","text":"Name Data type Description value <code>unknown</code> The value to check. Must be an array of the same length as <code>guards</code>. guards Readonly array of guard functions One guard per tuple position. Each guard must accept <code>unknown</code> and return a boolean or a type predicate."},{"location":"reference/type-guards/structural/is-tuple/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If value is an array of the same length as guards and each element passes its corresponding guard.</li> <li><code>false</code>: Otherwise.</li> </ul>"},{"location":"reference/type-guards/structural/is-tuple/#examples","title":"Examples","text":"<pre><code>isTuple([1, 'x'], [isNumber, isString] as const);\n// \u2192 true\n\nisTuple([1, 2], [isNumber, isString] as const);\n// \u2192 false\n\nisTuple([1], [isNumber, isString] as const);\n// \u2192 false\n</code></pre>"},{"location":"reference/type-guards/structural/is-tuple/#notes","title":"Notes","text":"<ul> <li>This helper is structural. It does not rely on TypeScript metadata.</li> <li>The <code>guards</code> parameter must be provided as a tuple literal or a <code>const</code> tuple for correct inference.</li> <li>Each guard is checked at runtime for safety; non-function guards cause the check to fail.</li> <li>Use <code>validateTuple</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/type-guards/structural/is-tuple/#next-up","title":"Next up","text":"<p>This is the final topic for structural type guards. In the next section, we'll cover collection-based type guards.</p> <p>Collections</p>"}]}