{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Jane","text":"<p>Zero\u2011side\u2011effect normalization and validation helpers for JavaScript.</p> <p>Jane is a small, clarity\u2011first helper library for normalizing, validating, and safely parsing unknown input in JavaScript and TypeScript.</p> <p>It\u2019s built for developers who want predictable behavior, composable pipelines, and zero surprises \u2014 without schema systems, decorators, or framework lock\u2011in.</p> <p>Jane is intentionally small. Intentionally explicit. Intentionally boring in all the right ways.</p>"},{"location":"#why-jane","title":"Why Jane?","text":"<p>Most validation libraries try to be everything: schema builders, type generators, transformers, parsers, refiners, and runtime type systems.</p> <p>Jane takes the opposite approach.</p> <p>Jane is:</p> <ul> <li>\u2705 Pure: No side effects, no hidden mutations.</li> <li>\u2705 Deterministic: Same input, same output, every time.</li> <li>\u2705 Composable: Build pipelines with <code>pipe()</code>.</li> <li>\u2705 Zero\u2011dependency: No runtime weight.</li> <li>\u2705 Framework\u2011agnostic: Works in Node, serverless, workers, Express, Fastify, Bun, Deno.</li> <li>\u2705 Focused: Normalization \u2192 validation \u2192 result.</li> </ul> <p>If you want a dependable \u201cstandard library\u201d for data sanity, Jane is your girl.</p>"},{"location":"#who-is-jane-for","title":"Who is Jane for?","text":"<p>Jane is designed for developers who:</p> <ul> <li>Prefer explicit, predictable behavior over magic.</li> <li>Want pure functions instead of schema DSLs.</li> <li>Need safe parsing for config, requests, queries, and internal boundaries.</li> <li>Value clarity and maintainability in long\u2011lived codebases.</li> <li>Dislike validators that throw.</li> <li>Want small, composable building blocks instead of monolithic schemas.</li> </ul> <p>If you\u2019ve ever written your own tiny normalizers and validators because existing libraries felt too heavy \u2014 Jane was built for you.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>npm install @steven-clements/jane\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation is available at:</p> <ul> <li>Project overview</li> <li>Reference</li> <li>Contributing</li> </ul>"},{"location":"#license","title":"License","text":"<p>Jane is licensed under the Apache License, Version 2.0.</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p>"},{"location":"#author","title":"Author","text":"<p>Steven \"Chris\" Clements</p> <p>Designed for clarity, composability, and long\u2011term maintainability.</p>"},{"location":"contributing/development-workflow/","title":"Follow the development workflow","text":"<p>Jane follows a clarity\u2011first, contract\u2011driven workflow. Every change begins with an explicit description of the intended behavior before any implementation work is done.</p> <p>The workflow is:</p> <ol> <li> <p>Write a reference topic</p> <p>Describe the module\u2019s purpose, inputs, outputs, constraints, and edge cases in <code>docs/reference/</code>.</p> <p>The reference topic is the human\u2011readable contract.</p> </li> <li> <p>Write the tests</p> <p>Translate your reference topic into executable expectations using Vitest.</p> <p>Tests should cover:</p> <ul> <li>Expected behavior.</li> <li>Invalid inputs.</li> <li>Edge cases.</li> <li>Type\u2011level expectations (if applicable).</li> </ul> <p>Tests are the executable contract.</p> </li> <li> <p>Write the implementation </p> <p>Implement the module so that it satisfies the spec and passes all tests.</p> <p>Keep modules small, explicit, and free of side effects.</p> </li> <li> <p>Update documentation </p> <p>If the change affects public behavior, update the relevant docs in <code>docs/</code>.</p> </li> <li> <p>Commit using semantic messages </p> <p>Use Conventional Commits to ensure automated releases and changelog updates:</p> <ul> <li><code>feat:</code> for new features</li> <li><code>fix:</code> for bug fixes</li> <li><code>docs:</code> for documentation changes</li> <li><code>refactor:</code> for internal changes</li> <li><code>test:</code> for test\u2011only changes</li> <li><code>chore:</code> for non\u2011code tasks</li> </ul> </li> </ol> <p>This workflow ensures that behavior is defined before it is implemented, tests reflect the intended contract, and the codebase remains predictable and maintainable.</p>"},{"location":"contributing/overview/","title":"Contributing","text":"<ul> <li>Development workflow</li> <li>Restricted files and directories</li> </ul>"},{"location":"contributing/restricted-repo-files/","title":"Restricted repo files","text":"<p>This project uses automated tooling for releases, formatting, documentation, and configuration.  </p> <p>To keep the repository stable and predictable, certain files must not be edited in pull requests unless explicitly requested by a maintainer.</p>"},{"location":"contributing/restricted-repo-files/#do-not-modify-these-files","title":"Do not modify these files","text":"<ul> <li>CHANGELOG.md: Automatically generated by the release pipeline. Any manual edits will be overwritten.</li> <li>CODEOWNERS: Defines review and approval rules. Changes require maintainer approval and are not accepted through general PRs.</li> <li> <p>LICENSE: Legal document. Only maintainers may update it.</p> </li> <li> <p>Release and automation configs:</p> </li> </ul> <p>These files are part of the automated release and CI/CD pipeline and must remain stable:</p> <ul> <li><code>.releaserc</code> or <code>release.config.*</code></li> <li><code>.github/workflows/*</code></li> <li><code>package.json</code> (release\u2011related fields)</li> <li> <p><code>semantic-release</code> configuration</p> </li> <li> <p>Formatting and linting configs:</p> </li> </ul> <p>These define the project\u2019s formatting and linting rules:</p> <ul> <li><code>prettier.config.*</code></li> <li><code>eslint.config.*</code></li> <li><code>.editorconfig</code></li> <li><code>tsconfig.json</code></li> <li> <p><code>vitest.config.*</code></p> </li> <li> <p>Root\u2011level configuration files:</p> </li> </ul> <p>Unless a maintainer requests a change, do not modify files at the repository root (except <code>README.md</code> and <code>mkdocs.yml</code>).</p>"},{"location":"contributing/restricted-repo-files/#allowed-areas-for-contributions","title":"Allowed areas for contributions","text":"<p>Most contributions should be limited to:</p> <ul> <li><code>mkdocs.yml</code> \u2014 documentation site navigation</li> <li><code>README.md</code> \u2014 General project information (raise the bar!).</li> <li><code>src/</code> \u2014 implementation  </li> <li><code>tests/</code> \u2014 test suites  </li> <li><code>docs/</code> \u2014 documentation  </li> <li><code>coverage/</code> \u2014 generated coverage artifacts (rarely edited manually)</li> </ul>"},{"location":"contributing/restricted-repo-files/#exceptions","title":"Exceptions","text":"<p>If a change to a restricted file is required to fix a bug, improve documentation, or resolve a configuration issue, please open an issue first.</p> <p>A maintainer will confirm whether the change is appropriate before a PR is opened.</p> <p>This policy ensures:</p> <ul> <li>Consistent automation.</li> <li>Predictable releases.</li> <li>Stable contributor experience.</li> <li>Clear separation between code and infrastructure.</li> </ul>"},{"location":"reference/overview/","title":"Reference","text":"<p>The Reference section documents every helper in Jane. Each page includes a clear description, the function signature, parameter tables, return shapes, examples, and notes. All helpers follow the same predictable structure so you can find what you need quickly.</p> <p>Use this section when you already understand the concepts and workflows, and you need precise details about a specific helper.</p>"},{"location":"reference/overview/#whats-included","title":"What\u2019s included","text":"<p>Jane includes several categories of helpers. Each category has its own index page and detailed entries for every function.</p>"},{"location":"reference/overview/#type-guards","title":"Type Guards","text":"<p>Helpers that check types and shapes without throwing.</p> <p>Use these when you need safe branching logic.</p> <p>Learn more</p>"},{"location":"reference/overview/#how-to-read-this-section","title":"How to read this section","text":"<p>Each helper is documented with:</p> <ul> <li>A short description.</li> <li>The function signature.</li> <li>A parameter table.</li> <li>The return shape.</li> <li>Examples.</li> <li>Notes and edge cases.</li> </ul> <p>Every entry is self\u2011contained and predictable. You can read them in any order.</p>"},{"location":"reference/guards/","title":"Type guards","text":"<p>Type guards help you safely branch logic and validate shapes without throwing exceptions. They return simple booleans and never mutate input. Use them when you need to confirm a value\u2019s type before running a normalization or validation step.</p> <p>Type guards are pure, predictable, and consistent. They make your workflows easier to read and easier to reason about.</p>"},{"location":"reference/guards/#available-type-guards","title":"Available type guards","text":"<p>Each type guard has its own reference page with examples and edge cases.</p>"},{"location":"reference/guards/#strings","title":"Strings","text":"<ul> <li>isString: Checks whether a value is a string.</li> <li>isNonEmptyString: Checks for a non\u2011empty string.</li> </ul>"},{"location":"reference/guards/#numbers","title":"Numbers","text":"<ul> <li>isNumber: Checks whether a value is a number.</li> <li>isInteger: Checks whether a value is an integer.</li> </ul>"},{"location":"reference/guards/#when-to-use-type-guards","title":"When to use type guards","text":"<p>Use type guards when:</p> <ul> <li>You need to branch logic based on type.</li> <li>You want to avoid exceptions.</li> <li>You want predictable behavior in pipelines.</li> <li>You need to confirm a value\u2019s shape before normalization.</li> <li>You want to write defensive code without clutter.</li> </ul> <p>Type guards are the simplest building blocks in Jane. They help you write clear, explicit workflows.</p>"},{"location":"reference/guards/is-integer/","title":"isInteger","text":"<p>Checks whether a value is a finite integer. This helper never throws and never mutates input. Use it when you need to confirm integer types before running normalization or validation.</p>"},{"location":"reference/guards/is-integer/#signature","title":"Signature","text":"<pre><code>function isInteger(value: any): value is number\n</code></pre>"},{"location":"reference/guards/is-integer/#parameters","title":"Parameters","text":"Name Data type Description value <code>any</code> The value to check. This helper performs a strict <code>typeof</code> check and only returns <code>true</code> for finite primitive integers."},{"location":"reference/guards/is-integer/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code> if the value is a finite integer.</li> <li><code>false</code> otherwise.</li> </ul> <pre><code>Examples\nisInteger(42)          // true\nisInteger(0)           // true\nisInteger(-10)         // true\nisInteger(3.14)        // false\nisInteger(NaN)         // false\nisInteger(Infinity)    // false\nisInteger(\"123\")       // false\nisInteger(null)        // false\n</code></pre>"},{"location":"reference/guards/is-integer/#notes","title":"Notes","text":"<ul> <li>This helper uses <code>Number.isInteger</code> internally, which rejects <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code>.</li> <li>Use <code>normalizeInteger</code> if you need to convert values into integers.</li> <li>Use <code>validateInteger</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/guards/is-non-empty-string/","title":"isNonEmptyString","text":"<p>Checks whether a value is a primitive, non\u2011empty string. This helper never throws and never mutates input. It performs a strict <code>typeof</code> check and does not trim or normalize the value.</p>"},{"location":"reference/guards/is-non-empty-string/#signature","title":"Signature","text":"<pre><code>function isNonEmptyString(value: any): value is string\n</code></pre>"},{"location":"reference/guards/is-non-empty-string/#parameters","title":"Parameters","text":"Name Data type Description value <code>any</code> The value to check. This helper performs a strict <code>typeof</code> check and only returns <code>true</code> for finite primitive integers."},{"location":"reference/guards/is-non-empty-string/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code>: If the value is a primitive string with length greater than 0.</li> <li><code>false</code> Otherwise.</li> </ul>"},{"location":"reference/guards/is-non-empty-string/#examples","title":"Examples","text":"<pre><code>isNonEmptyString(\"hello\")            // true\nisNonEmptyString(\" \")                // true (whitespace counts as non-empty)\nisNonEmptyString(\"\")                 // false\nisNonEmptyString(123)                // false\nisNonEmptyString(null)               // false\nisNonEmptyString(undefined)          // false\nisNonEmptyString(new String(\"x\"))    // false\n</code></pre>"},{"location":"reference/guards/is-non-empty-string/#notes","title":"Notes","text":"<ul> <li>This helper does not trim whitespace.</li> <li>Zero\u2011width characters still count as non\u2011empty.</li> <li>This helper returns <code>false</code> for String objects (e.g., <code>new String(\"x\")</code>).</li> <li>Use <code>normalizeNonEmptyString</code> if you need trimming and conversion.</li> <li>Use <code>validateNonEmptyString</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/guards/is-number/","title":"isNumber","text":"<p>Checks whether a value is a finite primitive number. This helper never throws and never mutates input. Use it when you need to confirm numeric types before running normalization or validation.</p>"},{"location":"reference/guards/is-number/#signature","title":"Signature","text":"<pre><code>function isNumber(value: any): value is number\n</code></pre>"},{"location":"reference/guards/is-number/#parameters","title":"Parameters","text":"Name Data type Description value <code>any</code> The value to check. This helper performs a strict <code>typeof</code> check and only returns <code>true</code> for finite primitive integers."},{"location":"reference/guards/is-number/#returns","title":"Returns","text":"<p>A boolean:</p> <ul> <li><code>true</code> if the value is a finite primitive number</li> <li><code>false</code> otherwise</li> </ul>"},{"location":"reference/guards/is-number/#examples","title":"Examples","text":"<pre><code>isNumber(42)          // true\nisNumber(0)           // true\nisNumber(-3.14)       // true\nisNumber(NaN)         // false\nisNumber(Infinity)    // false\nisNumber(\"123\")       // false\nisNumber(null)        // false\nisNumber(undefined)   // false\n</code></pre>"},{"location":"reference/guards/is-number/#notes","title":"Notes","text":"<ul> <li>This helper rejects <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> because they are not meaningful numeric values.</li> <li>Use <code>isInteger</code> if you need to confirm integer values.</li> <li>Use <code>normalizeNumber</code> if you need to convert values into numbers.</li> <li>Use <code>validateNumber</code> if you need a <code>Result&lt;T&gt;</code> instead of a boolean.</li> </ul>"},{"location":"reference/guards/is-string/","title":"isString","text":"<p>Checks whether a value is a primitive string. This helper never throws and never mutates input. It performs a strict <code>typeof</code> check and does not coerce values.</p>"},{"location":"reference/guards/is-string/#signature","title":"Signature","text":"<pre><code>function isString(value: any): value is string\n</code></pre>"},{"location":"reference/guards/is-string/#parameters","title":"Parameters","text":"Name Data type Description value <code>any</code> The value to check. This helper performs a strict <code>typeof</code> check and only returns <code>true</code> for finite primitive integers."},{"location":"reference/guards/is-string/#returns","title":"Returns","text":"<ul> <li><code>true</code> if the value is a primitive string.</li> <li><code>false</code> otherwise.</li> </ul>"},{"location":"reference/guards/is-string/#examples","title":"Examples","text":"<pre><code>isString(\"hello\")               // true\nisString(\"\")                    // true\nisString(123)                   // false\nisString(null)                  // false\nisString(undefined)             // false\nisString({})                    // false\nisString([])                    // false\nisString(new String(\"hello\"))   // false\n</code></pre>"},{"location":"reference/guards/is-string/#notes","title":"Notes","text":"<ul> <li>This helper does not trim or modify the value.</li> <li>This helper returns <code>false</code> for String objects (for example, <code>new String(\"x\")</code>).</li> <li>Use <code>isNonEmptyString</code> if you need to ensure the string is not empty.</li> <li>Use <code>normalizeString</code> if you need to convert values into strings.</li> </ul>"}]}